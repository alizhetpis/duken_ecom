{"ast":null,"code":"/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\n\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar DataBlock = require('./datablock');\nvar BitMatrixParser = require('./bmparser');\nvar ReedSolomonDecoder = require('./rsdecoder');\nvar GF256 = require('./gf256');\nvar QRCodeDataBlockReader = require('./databr');\nvar Decoder = {};\nDecoder.rsDecoder = new ReedSolomonDecoder(GF256.QR_CODE_FIELD);\nDecoder.correctErrors = function (codewordBytes, numDataCodewords) {\n  var numCodewords = codewordBytes.length;\n  // First read into an array of ints\n  var codewordsInts = new Array(numCodewords);\n  for (var i = 0; i < numCodewords; i++) {\n    codewordsInts[i] = codewordBytes[i] & 0xFF;\n  }\n  var numECCodewords = codewordBytes.length - numDataCodewords;\n  try {\n    Decoder.rsDecoder.decode(codewordsInts, numECCodewords);\n    //var corrector = new ReedSolomon(codewordsInts, numECCodewords);\n    //corrector.correct();\n  } catch (rse) {\n    throw rse;\n  }\n  // Copy back into array of bytes -- only need to worry about the bytes that were data\n  // We don't care about errors in the error-correction codewords\n  for (var i = 0; i < numDataCodewords; i++) {\n    codewordBytes[i] = codewordsInts[i];\n  }\n};\nDecoder.decode = function (bits) {\n  var parser = new BitMatrixParser(bits);\n  var version = parser.readVersion();\n  var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;\n\n  // Read codewords\n  var codewords = parser.readCodewords();\n\n  // Separate into data blocks\n  var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\n\n  // Count total number of data bytes\n  var totalBytes = 0;\n  for (var i = 0; i < dataBlocks.Length; i++) {\n    totalBytes += dataBlocks[i].NumDataCodewords;\n  }\n  var resultBytes = new Array(totalBytes);\n  var resultOffset = 0;\n\n  // Error-correct and copy data blocks together into a stream of bytes\n  for (var j = 0; j < dataBlocks.length; j++) {\n    var dataBlock = dataBlocks[j];\n    var codewordBytes = dataBlock.Codewords;\n    var numDataCodewords = dataBlock.NumDataCodewords;\n    Decoder.correctErrors(codewordBytes, numDataCodewords);\n    for (var i = 0; i < numDataCodewords; i++) {\n      resultBytes[resultOffset++] = codewordBytes[i];\n    }\n  }\n\n  // Decode the contents of that stream of bytes\n  var reader = new QRCodeDataBlockReader(resultBytes, version.VersionNumber, ecLevel.Bits);\n  return reader;\n  //return DecodedBitStreamParser.decode(resultBytes, version, ecLevel);\n};\n\nmodule.exports = Decoder;","map":{"version":3,"names":["DataBlock","require","BitMatrixParser","ReedSolomonDecoder","GF256","QRCodeDataBlockReader","Decoder","rsDecoder","QR_CODE_FIELD","correctErrors","codewordBytes","numDataCodewords","numCodewords","length","codewordsInts","Array","i","numECCodewords","decode","rse","bits","parser","version","readVersion","ecLevel","readFormatInformation","ErrorCorrectionLevel","codewords","readCodewords","dataBlocks","getDataBlocks","totalBytes","Length","NumDataCodewords","resultBytes","resultOffset","j","dataBlock","Codewords","reader","VersionNumber","Bits","module","exports"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/jsqrcode/src/decoder.js"],"sourcesContent":["/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\r\n\r\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\nvar DataBlock = require('./datablock');\r\nvar BitMatrixParser = require('./bmparser');\r\nvar ReedSolomonDecoder = require('./rsdecoder');\r\nvar GF256 = require('./gf256');\r\nvar QRCodeDataBlockReader = require('./databr')\r\n\r\nvar Decoder = {};\r\nDecoder.rsDecoder = new ReedSolomonDecoder(GF256.QR_CODE_FIELD);\r\n\r\nDecoder.correctErrors=function( codewordBytes,  numDataCodewords)\r\n{\r\n  var numCodewords = codewordBytes.length;\r\n  // First read into an array of ints\r\n  var codewordsInts = new Array(numCodewords);\r\n  for (var i = 0; i < numCodewords; i++)\r\n  {\r\n    codewordsInts[i] = codewordBytes[i] & 0xFF;\r\n  }\r\n  var numECCodewords = codewordBytes.length - numDataCodewords;\r\n  try\r\n  {\r\n    Decoder.rsDecoder.decode(codewordsInts, numECCodewords);\r\n    //var corrector = new ReedSolomon(codewordsInts, numECCodewords);\r\n    //corrector.correct();\r\n  }\r\n  catch ( rse)\r\n  {\r\n    throw rse;\r\n  }\r\n  // Copy back into array of bytes -- only need to worry about the bytes that were data\r\n  // We don't care about errors in the error-correction codewords\r\n  for (var i = 0; i < numDataCodewords; i++)\r\n  {\r\n    codewordBytes[i] =  codewordsInts[i];\r\n  }\r\n}\r\n\r\nDecoder.decode=function(bits)\r\n{\r\n  var parser = new BitMatrixParser(bits);\r\n  var version = parser.readVersion();\r\n  var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;\r\n  \r\n  // Read codewords\r\n  var codewords = parser.readCodewords();\r\n\r\n  // Separate into data blocks\r\n  var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\r\n  \r\n  // Count total number of data bytes\r\n  var totalBytes = 0;\r\n  for (var i = 0; i < dataBlocks.Length; i++)\r\n  {\r\n    totalBytes += dataBlocks[i].NumDataCodewords;\r\n  }\r\n  var resultBytes = new Array(totalBytes);\r\n  var resultOffset = 0;\r\n  \r\n  // Error-correct and copy data blocks together into a stream of bytes\r\n  for (var j = 0; j < dataBlocks.length; j++)\r\n  {\r\n    var dataBlock = dataBlocks[j];\r\n    var codewordBytes = dataBlock.Codewords;\r\n    var numDataCodewords = dataBlock.NumDataCodewords;\r\n    Decoder.correctErrors(codewordBytes, numDataCodewords);\r\n    for (var i = 0; i < numDataCodewords; i++)\r\n    {\r\n      resultBytes[resultOffset++] = codewordBytes[i];\r\n    }\r\n  }\r\n  \r\n  // Decode the contents of that stream of bytes\r\n  var reader = new QRCodeDataBlockReader(resultBytes, version.VersionNumber, ecLevel.Bits);\r\n  return reader;\r\n  //return DecodedBitStreamParser.decode(resultBytes, version, ecLevel);\r\n}\r\n\r\n\r\nmodule.exports = Decoder;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}