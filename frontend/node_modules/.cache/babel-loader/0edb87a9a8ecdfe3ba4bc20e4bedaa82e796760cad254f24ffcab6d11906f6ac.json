{"ast":null,"code":"/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\n\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar PerspectiveTransform = require('./perspective-transform');\nvar BitMatrix = require('./bitmat');\nvar qrcode = require('./qrcode')();\nGridSampler = {};\nGridSampler.checkAndNudgePoints = function (image, points) {\n  var width = qrcode.width;\n  var height = qrcode.height;\n  // Check and nudge points from start until we see some that are OK:\n  var nudged = true;\n  for (var offset = 0; offset < points.Length && nudged; offset += 2) {\n    var x = Math.floor(points[offset]);\n    var y = Math.floor(points[offset + 1]);\n    if (x < -1 || x > width || y < -1 || y > height) {\n      throw \"Error.checkAndNudgePoints \";\n    }\n    nudged = false;\n    if (x == -1) {\n      points[offset] = 0.0;\n      nudged = true;\n    } else if (x == width) {\n      points[offset] = width - 1;\n      nudged = true;\n    }\n    if (y == -1) {\n      points[offset + 1] = 0.0;\n      nudged = true;\n    } else if (y == height) {\n      points[offset + 1] = height - 1;\n      nudged = true;\n    }\n  }\n  // Check and nudge points from end:\n  nudged = true;\n  for (var offset = points.Length - 2; offset >= 0 && nudged; offset -= 2) {\n    var x = Math.floor(points[offset]);\n    var y = Math.floor(points[offset + 1]);\n    if (x < -1 || x > width || y < -1 || y > height) {\n      throw \"Error.checkAndNudgePoints \";\n    }\n    nudged = false;\n    if (x == -1) {\n      points[offset] = 0.0;\n      nudged = true;\n    } else if (x == width) {\n      points[offset] = width - 1;\n      nudged = true;\n    }\n    if (y == -1) {\n      points[offset + 1] = 0.0;\n      nudged = true;\n    } else if (y == height) {\n      points[offset + 1] = height - 1;\n      nudged = true;\n    }\n  }\n};\nGridSampler.sampleGrid3 = function (image, dimension, transform) {\n  var bits = new BitMatrix(dimension);\n  var points = new Array(dimension << 1);\n  for (var y = 0; y < dimension; y++) {\n    var max = points.length;\n    var iValue = y + 0.5;\n    for (var x = 0; x < max; x += 2) {\n      points[x] = (x >> 1) + 0.5;\n      points[x + 1] = iValue;\n    }\n    transform.transformPoints1(points);\n    // Quick check to see if points transformed to something inside the image;\n    // sufficient to check the endpoints\n    GridSampler.checkAndNudgePoints(image, points);\n    try {\n      for (var x = 0; x < max; x += 2) {\n        var xpoint = Math.floor(points[x]) * 4 + Math.floor(points[x + 1]) * qrcode.width * 4;\n        var bit = image[Math.floor(points[x]) + qrcode.width * Math.floor(points[x + 1])];\n        qrcode.imagedata.data[xpoint] = bit ? 255 : 0;\n        qrcode.imagedata.data[xpoint + 1] = bit ? 255 : 0;\n        qrcode.imagedata.data[xpoint + 2] = 0;\n        qrcode.imagedata.data[xpoint + 3] = 255;\n        //bits[x >> 1][ y]=bit;\n        if (bit) bits.set_Renamed(x >> 1, y);\n      }\n    } catch (aioobe) {\n      // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n      // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n      // whose endpoints are in bounds, but others are not. There is probably some mathematical\n      // way to detect this about the transformation that I don't know yet.\n      // This results in an ugly runtime exception despite our clever checks above -- can't have\n      // that. We could check each point's coordinates but that feels duplicative. We settle for\n      // catching and wrapping ArrayIndexOutOfBoundsException.\n      throw \"Error.checkAndNudgePoints\";\n    }\n  }\n  return bits;\n};\nGridSampler.sampleGridx = function (image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {\n  var transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\n  return GridSampler.sampleGrid3(image, dimension, transform);\n};\nmodule.exports = GridSampler;","map":{"version":3,"names":["PerspectiveTransform","require","BitMatrix","qrcode","GridSampler","checkAndNudgePoints","image","points","width","height","nudged","offset","Length","x","Math","floor","y","sampleGrid3","dimension","transform","bits","Array","max","length","iValue","transformPoints1","xpoint","bit","imagedata","data","set_Renamed","aioobe","sampleGridx","p1ToX","p1ToY","p2ToX","p2ToY","p3ToX","p3ToY","p4ToX","p4ToY","p1FromX","p1FromY","p2FromX","p2FromY","p3FromX","p3FromY","p4FromX","p4FromY","quadrilateralToQuadrilateral","module","exports"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/jsqrcode/src/grid.js"],"sourcesContent":["/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\r\n\r\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\nvar PerspectiveTransform = require('./perspective-transform');\r\nvar BitMatrix = require('./bitmat');\r\nvar qrcode = require('./qrcode')();\r\n\r\nGridSampler = {};\r\n\r\nGridSampler.checkAndNudgePoints=function( image,  points) {\r\n  var width = qrcode.width;\r\n  var height = qrcode.height;\r\n  // Check and nudge points from start until we see some that are OK:\r\n  var nudged = true;\r\n  for (var offset = 0; offset < points.Length && nudged; offset += 2) {\r\n    var x = Math.floor (points[offset]);\r\n    var y = Math.floor( points[offset + 1]);\r\n    if (x < - 1 || x > width || y < - 1 || y > height)\r\n        {\r\n          throw \"Error.checkAndNudgePoints \";\r\n        }\r\n        nudged = false;\r\n        if (x == - 1)\r\n        {\r\n          points[offset] = 0.0;\r\n          nudged = true;\r\n        }\r\n        else if (x == width)\r\n        {\r\n          points[offset] = width - 1;\r\n          nudged = true;\r\n        }\r\n        if (y == - 1)\r\n        {\r\n          points[offset + 1] = 0.0;\r\n          nudged = true;\r\n        }\r\n        else if (y == height)\r\n        {\r\n          points[offset + 1] = height - 1;\r\n          nudged = true;\r\n        }\r\n      }\r\n      // Check and nudge points from end:\r\n      nudged = true;\r\n      for (var offset = points.Length - 2; offset >= 0 && nudged; offset -= 2)\r\n      {\r\n        var x = Math.floor( points[offset]);\r\n        var y = Math.floor( points[offset + 1]);\r\n        if (x < - 1 || x > width || y < - 1 || y > height)\r\n        {\r\n          throw \"Error.checkAndNudgePoints \";\r\n        }\r\n        nudged = false;\r\n        if (x == - 1)\r\n        {\r\n          points[offset] = 0.0;\r\n          nudged = true;\r\n        }\r\n        else if (x == width)\r\n        {\r\n          points[offset] = width - 1;\r\n          nudged = true;\r\n        }\r\n        if (y == - 1)\r\n        {\r\n          points[offset + 1] = 0.0;\r\n          nudged = true;\r\n        }\r\n        else if (y == height)\r\n        {\r\n          points[offset + 1] = height - 1;\r\n          nudged = true;\r\n        }\r\n      }\r\n    }\r\n  \r\n\r\n\r\nGridSampler.sampleGrid3 = function( image,  dimension,  transform)\r\n    {\r\n      var bits = new BitMatrix(dimension);\r\n      var points = new Array(dimension << 1);\r\n      for (var y = 0; y < dimension; y++)\r\n      {\r\n        var max = points.length;\r\n        var iValue =  y + 0.5;\r\n        for (var x = 0; x < max; x += 2)\r\n        {\r\n          points[x] =  (x >> 1) + 0.5;\r\n          points[x + 1] = iValue;\r\n        }\r\n        transform.transformPoints1(points);\r\n        // Quick check to see if points transformed to something inside the image;\r\n        // sufficient to check the endpoints\r\n        GridSampler.checkAndNudgePoints(image, points);\r\n        try\r\n        {\r\n          for (var x = 0; x < max; x += 2)\r\n          {\r\n            var xpoint = (Math.floor( points[x]) * 4) + (Math.floor( points[x + 1]) * qrcode.width * 4);\r\n                        var bit = image[Math.floor( points[x])+ qrcode.width* Math.floor( points[x + 1])];\r\n            qrcode.imagedata.data[xpoint] = bit?255:0;\r\n            qrcode.imagedata.data[xpoint+1] = bit?255:0;\r\n            qrcode.imagedata.data[xpoint+2] = 0;\r\n            qrcode.imagedata.data[xpoint+3] = 255;\r\n            //bits[x >> 1][ y]=bit;\r\n            if(bit)\r\n              bits.set_Renamed(x >> 1, y);\r\n          }\r\n        }\r\n        catch ( aioobe)\r\n        {\r\n          // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\r\n          // transform gets \"twisted\" such that it maps a straight line of points to a set of points\r\n          // whose endpoints are in bounds, but others are not. There is probably some mathematical\r\n          // way to detect this about the transformation that I don't know yet.\r\n          // This results in an ugly runtime exception despite our clever checks above -- can't have\r\n          // that. We could check each point's coordinates but that feels duplicative. We settle for\r\n          // catching and wrapping ArrayIndexOutOfBoundsException.\r\n          throw \"Error.checkAndNudgePoints\";\r\n        }\r\n      }\r\n      return bits;\r\n    }\r\n\r\nGridSampler.sampleGridx = function( image,  dimension,  p1ToX,  p1ToY,  p2ToX,  p2ToY,  p3ToX,  p3ToY,  p4ToX,  p4ToY,  p1FromX,  p1FromY,  p2FromX,  p2FromY,  p3FromX,  p3FromY,  p4FromX,  p4FromY)\r\n{\r\n  var transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\r\n      \r\n  return GridSampler.sampleGrid3(image, dimension, transform);\r\n}\r\n\r\nmodule.exports = GridSampler"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}