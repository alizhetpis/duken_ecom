{"ast":null,"code":"'use strict';\n\nvar base32 = require('base32.js');\nvar crypto = require('crypto');\nvar url = require('url');\nvar util = require('util');\n\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\nexports.digest = function digest(options) {\n  var i;\n\n  // unpack options\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n\n  // Backwards compatibility - deprecated\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  }\n\n  // convert secret to buffer\n  if (!Buffer.isBuffer(secret)) {\n    secret = encoding === 'base32' ? base32.decode(secret) : new Buffer(secret, encoding);\n  }\n\n  // create an buffer from the counter\n  var buf = new Buffer(8);\n  var tmp = counter;\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff;\n\n    // shift 8 and get ready to loop over the next batch of 8\n    tmp = tmp >> 8;\n  }\n\n  // init hmac with the key\n  var hmac = crypto.createHmac(algorithm, secret);\n\n  // update hmac with the counter\n  hmac.update(buf);\n\n  // return the digest\n  return hmac.digest();\n};\n\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.hotp = function hotpGenerate(options) {\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');\n\n  // digest the options\n  var digest = options.digest || exports.digest(options);\n\n  // compute HOTP offset\n  var offset = digest[digest.length - 1] & 0xf;\n\n  // calculate binary code (RFC4226 5.4)\n  var code = (digest[offset] & 0x7f) << 24 | (digest[offset + 1] & 0xff) << 16 | (digest[offset + 2] & 0xff) << 8 | digest[offset + 3] & 0xff;\n\n  // left-pad code\n  code = new Array(digits + 1).join('0') + code.toString(10);\n\n  // return length number off digits\n  return code.substr(-digits);\n};\n\n// Alias counter() for hotp()\nexports.counter = exports.hotp;\n\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp․verifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta(options) {\n  var i;\n\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0;\n\n  // fail if token is not of correct length\n  if (token.length !== digits) {\n    return;\n  }\n\n  // parse token to integer\n  token = parseInt(token, 10);\n\n  // fail if token is NA\n  if (isNaN(token)) {\n    return;\n  }\n\n  // loop from C to C + W inclusive\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i;\n    // domain-specific constant-time comparison for integer codes\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {\n        delta: i - counter\n      };\n    }\n  }\n\n  // no codes have matched\n};\n\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp․verify\n * @global\n */\nexports.hotp.verify = function hotpVerify(options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\nexports._counter = function _counter(options) {\n  var step = options.step || 30;\n  var time = options.time != null ? options.time * 1000 : Date.now();\n\n  // also accepts 'initial_time', but deprecated\n  var epoch = (options.epoch != null ? options.epoch * 1000 : options.initial_time * 1000) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n  return Math.floor((time - epoch) / step / 1000);\n};\n\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.totp = function totpGenerate(options) {\n  // shadow options\n  options = Object.create(options);\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // pass to hotp\n  return this.hotp(options);\n};\n\n// Alias time() for totp()\nexports.time = exports.totp;\n\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp․verifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta(options) {\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var window = parseInt(options.window, 10) || 0;\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // adjust for two-sided window\n  options.counter -= window;\n  options.window += window;\n\n  // pass to hotp.verifyDelta\n  var delta = exports.hotp.verifyDelta(options);\n\n  // adjust for two-sided window\n  if (delta) {\n    delta.delta -= window;\n  }\n  return delta;\n};\n\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp․verify\n * @global\n */\nexports.totp.verify = function totpVerify(options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\nexports.generateSecret = function generateSecret(options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = encodeURIComponent(options.name || 'SecretKey');\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n\n  // turn off symbols only when explicity told to\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  }\n\n  // generate an ascii key\n  var key = this.generateSecretASCII(length, symbols);\n\n  // return a SecretKey with ascii, hex, and base32\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, '');\n\n  // generate some qr codes if requested\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  }\n\n  // add in the Google Authenticator-compatible otpauth URL\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name\n    });\n  }\n\n  // generate a QR code for use in Google Authenticator if requested\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({\n      secret: SecretKey.base32,\n      label: name\n    }));\n  }\n  return SecretKey;\n};\n\n// Backwards compatibility - generate_key is deprecated\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\nexports.generateSecretASCII = function generateSecretASCII(length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n  var output = '';\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n  return output;\n};\n\n// Backwards compatibility - generate_key_ascii is deprecated\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL(options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = options.algorithm;\n  var digits = options.digits;\n  var period = options.period;\n  var encoding = options.encoding || 'ascii';\n\n  // validate type\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  }\n\n  // validate required options\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label');\n\n  // require counter for HOTP\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  }\n\n  // convert secret to base32\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret);\n\n  // build query while validating\n  var query = {\n    secret: secret\n  };\n  if (issuer) query.issuer = issuer;\n\n  // validate algorithm\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n    query.algorithm = algorithm.toUpperCase();\n  }\n\n  // validate digits\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n    query.digits = digits;\n  }\n\n  // validate period\n  if (period != null) {\n    period = parseInt(period, 10);\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n    query.period = period;\n  }\n\n  // return url\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: label,\n    query: query\n  });\n};","map":{"version":3,"names":["base32","require","crypto","url","util","exports","digest","options","i","secret","counter","encoding","algorithm","toLowerCase","key","console","warn","Buffer","isBuffer","decode","buf","tmp","hmac","createHmac","update","hotp","hotpGenerate","digits","length","offset","code","Array","join","toString","substr","verifyDelta","hotpVerifyDelta","Object","create","token","String","parseInt","window","isNaN","delta","verify","hotpVerify","_counter","step","time","Date","now","epoch","initial_time","Math","floor","totp","totpGenerate","totpVerifyDelta","totpVerify","generateSecret","name","encodeURIComponent","qr_codes","google_auth_qr","otpauth_url","symbols","undefined","generateSecretASCII","SecretKey","ascii","hex","encode","replace","qr_code_ascii","qr_code_hex","qr_code_base32","otpauthURL","label","generate_key","deprecate","bytes","randomBytes","set","output","l","generate_key_ascii","issuer","type","period","Error","query","toUpperCase","format","protocol","slashes","hostname","pathname"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/speakeasy/index.js"],"sourcesContent":["'use strict';\n\nvar base32 = require('base32.js');\nvar crypto = require('crypto');\nvar url = require('url');\nvar util = require('util');\n\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\nexports.digest = function digest (options) {\n  var i;\n\n  // unpack options\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n\n  // Backwards compatibility - deprecated\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  }\n\n  // convert secret to buffer\n  if (!Buffer.isBuffer(secret)) {\n    secret = encoding === 'base32' ? base32.decode(secret)\n      : new Buffer(secret, encoding);\n  }\n\n  // create an buffer from the counter\n  var buf = new Buffer(8);\n  var tmp = counter;\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff;\n\n    // shift 8 and get ready to loop over the next batch of 8\n    tmp = tmp >> 8;\n  }\n\n  // init hmac with the key\n  var hmac = crypto.createHmac(algorithm, secret);\n\n  // update hmac with the counter\n  hmac.update(buf);\n\n  // return the digest\n  return hmac.digest();\n};\n\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.hotp = function hotpGenerate (options) {\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');\n\n  // digest the options\n  var digest = options.digest || exports.digest(options);\n\n  // compute HOTP offset\n  var offset = digest[digest.length - 1] & 0xf;\n\n  // calculate binary code (RFC4226 5.4)\n  var code = (digest[offset] & 0x7f) << 24 |\n    (digest[offset + 1] & 0xff) << 16 |\n    (digest[offset + 2] & 0xff) << 8 |\n    (digest[offset + 3] & 0xff);\n\n  // left-pad code\n  code = new Array(digits + 1).join('0') + code.toString(10);\n\n  // return length number off digits\n  return code.substr(-digits);\n};\n\n// Alias counter() for hotp()\nexports.counter = exports.hotp;\n\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp․verifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta (options) {\n  var i;\n\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0;\n\n  // fail if token is not of correct length\n  if (token.length !== digits) {\n    return;\n  }\n\n  // parse token to integer\n  token = parseInt(token, 10);\n\n  // fail if token is NA\n  if (isNaN(token)) {\n    return;\n  }\n\n  // loop from C to C + W inclusive\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i;\n    // domain-specific constant-time comparison for integer codes\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {delta: i - counter};\n    }\n  }\n\n  // no codes have matched\n};\n\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp․verify\n * @global\n */\nexports.hotp.verify = function hotpVerify (options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\nexports._counter = function _counter (options) {\n  var step = options.step || 30;\n  var time = options.time != null ? (options.time * 1000) : Date.now();\n\n  // also accepts 'initial_time', but deprecated\n  var epoch = (options.epoch != null ? (options.epoch * 1000) : (options.initial_time * 1000)) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n\n  return Math.floor((time - epoch) / step / 1000);\n};\n\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.totp = function totpGenerate (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // pass to hotp\n  return this.hotp(options);\n};\n\n// Alias time() for totp()\nexports.time = exports.totp;\n\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp․verifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var window = parseInt(options.window, 10) || 0;\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // adjust for two-sided window\n  options.counter -= window;\n  options.window += window;\n\n  // pass to hotp.verifyDelta\n  var delta = exports.hotp.verifyDelta(options);\n\n  // adjust for two-sided window\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp․verify\n * @global\n */\nexports.totp.verify = function totpVerify (options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\nexports.generateSecret = function generateSecret (options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = encodeURIComponent(options.name || 'SecretKey');\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n\n  // turn off symbols only when explicity told to\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  }\n\n  // generate an ascii key\n  var key = this.generateSecretASCII(length, symbols);\n\n  // return a SecretKey with ascii, hex, and base32\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, '');\n\n  // generate some qr codes if requested\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  }\n\n  // add in the Google Authenticator-compatible otpauth URL\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name\n    });\n  }\n\n  // generate a QR code for use in Google Authenticator if requested\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({ secret: SecretKey.base32, label: name }));\n  }\n\n  return SecretKey;\n};\n\n// Backwards compatibility - generate_key is deprecated\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\nexports.generateSecretASCII = function generateSecretASCII (length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n  return output;\n};\n\n// Backwards compatibility - generate_key_ascii is deprecated\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL (options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = options.algorithm;\n  var digits = options.digits;\n  var period = options.period;\n  var encoding = options.encoding || 'ascii';\n\n  // validate type\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  }\n\n  // validate required options\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label');\n\n  // require counter for HOTP\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  }\n\n  // convert secret to base32\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret);\n\n  // build query while validating\n  var query = {secret: secret};\n  if (issuer) query.issuer = issuer;\n\n  // validate algorithm\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n    query.algorithm = algorithm.toUpperCase();\n  }\n\n  // validate digits\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n    query.digits = digits;\n  }\n\n  // validate period\n  if (period != null) {\n    period = parseInt(period, 10);\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n    query.period = period;\n  }\n\n  // return url\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: label,\n    query: query\n  });\n};\n"],"mappings":"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;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAnD,OAAO,CAACmD,IAAI,CAACrB,WAAW,GAAG,SAASuB,eAAe,CAAEnD,OAAO,EAAE;EAC5D;EACAA,OAAO,GAAG8B,MAAM,CAACC,MAAM,CAAC/B,OAAO,CAAC;;EAEhC;EACA,IAAImC,MAAM,GAAGD,QAAQ,CAAClC,OAAO,CAACmC,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC;;EAE9C;EACA,IAAInC,OAAO,CAACG,OAAO,IAAI,IAAI,EAAEH,OAAO,CAACG,OAAO,GAAGL,OAAO,CAAC0C,QAAQ,CAACxC,OAAO,CAAC;;EAExE;EACAA,OAAO,CAACG,OAAO,IAAIgC,MAAM;EACzBnC,OAAO,CAACmC,MAAM,IAAIA,MAAM;;EAExB;EACA,IAAIE,KAAK,GAAGvC,OAAO,CAACoB,IAAI,CAACU,WAAW,CAAC5B,OAAO,CAAC;;EAE7C;EACA,IAAIqC,KAAK,EAAE;IACTA,KAAK,CAACA,KAAK,IAAIF,MAAM;EACvB;EAEA,OAAOE,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvC,OAAO,CAACmD,IAAI,CAACX,MAAM,GAAG,SAASc,UAAU,CAAEpD,OAAO,EAAE;EAClD,OAAOF,OAAO,CAACmD,IAAI,CAACrB,WAAW,CAAC5B,OAAO,CAAC,IAAI,IAAI;AAClD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}