{"ast":null,"code":"/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\n\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar GF256Poly = require('./gf256poly');\nvar GF256 = require('./gf256');\nfunction ReedSolomonDecoder(field) {\n  this.field = field;\n  this.decode = function (received, twoS) {\n    var poly = new GF256Poly(this.field, received);\n    var syndromeCoefficients = new Array(twoS);\n    for (var i = 0; i < syndromeCoefficients.length; i++) syndromeCoefficients[i] = 0;\n    var dataMatrix = false; //this.field.Equals(GF256.DATA_MATRIX_FIELD);\n    var noError = true;\n    for (var i = 0; i < twoS; i++) {\n      // Thanks to sanfordsquires for this fix:\n      var eval = poly.evaluateAt(this.field.exp(dataMatrix ? i + 1 : i));\n      syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;\n      if (eval != 0) {\n        noError = false;\n      }\n    }\n    if (noError) {\n      return;\n    }\n    var syndrome = new GF256Poly(this.field, syndromeCoefficients);\n    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1];\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);\n    for (var i = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - this.field.log(errorLocations[i]);\n      if (position < 0) {\n        throw \"ReedSolomonException Bad error location\";\n      }\n      received[position] = GF256.addOrSubtract(received[position], errorMagnitudes[i]);\n    }\n  };\n  this.runEuclideanAlgorithm = function (a, b, R) {\n    // Assume a's degree is >= b's\n    if (a.Degree < b.Degree) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n    var rLast = a;\n    var r = b;\n    var sLast = this.field.One;\n    var s = this.field.Zero;\n    var tLast = this.field.Zero;\n    var t = this.field.One;\n\n    // Run Euclidean algorithm until r's degree is less than R/2\n    while (r.Degree >= Math.floor(R / 2)) {\n      var rLastLast = rLast;\n      var sLastLast = sLast;\n      var tLastLast = tLast;\n      rLast = r;\n      sLast = s;\n      tLast = t;\n\n      // Divide rLastLast by rLast, with quotient in q and remainder in r\n      if (rLast.Zero) {\n        // Oops, Euclidean algorithm already terminated?\n        throw \"r_{i-1} was zero\";\n      }\n      r = rLastLast;\n      var q = this.field.Zero;\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);\n      var dltInverse = this.field.inverse(denominatorLeadingTerm);\n      while (r.Degree >= rLast.Degree && !r.Zero) {\n        var degreeDiff = r.Degree - rLast.Degree;\n        var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);\n        q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));\n        r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n        //r.EXE();\n      }\n\n      s = q.multiply1(sLast).addOrSubtract(sLastLast);\n      t = q.multiply1(tLast).addOrSubtract(tLastLast);\n    }\n    var sigmaTildeAtZero = t.getCoefficient(0);\n    if (sigmaTildeAtZero == 0) {\n      throw \"ReedSolomonException sigmaTilde(0) was zero\";\n    }\n    var inverse = this.field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiply2(inverse);\n    var omega = r.multiply2(inverse);\n    return new Array(sigma, omega);\n  };\n  this.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.Degree;\n    if (numErrors == 1) {\n      // shortcut\n      return new Array(errorLocator.getCoefficient(1));\n    }\n    var result = new Array(numErrors);\n    var e = 0;\n    for (var i = 1; i < 256 && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) == 0) {\n        result[e] = this.field.inverse(i);\n        e++;\n      }\n    }\n    if (e != numErrors) {\n      throw \"Error locator degree does not match number of roots\";\n    }\n    return result;\n  };\n  this.findErrorMagnitudes = function (errorEvaluator, errorLocations, dataMatrix) {\n    // This is directly applying Forney's Formula\n    var s = errorLocations.length;\n    var result = new Array(s);\n    for (var i = 0; i < s; i++) {\n      var xiInverse = this.field.inverse(errorLocations[i]);\n      var denominator = 1;\n      for (var j = 0; j < s; j++) {\n        if (i != j) {\n          denominator = this.field.multiply(denominator, GF256.addOrSubtract(1, this.field.multiply(errorLocations[j], xiInverse)));\n        }\n      }\n      result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse), this.field.inverse(denominator));\n      // Thanks to sanfordsquires for this fix:\n      if (dataMatrix) {\n        result[i] = this.field.multiply(result[i], xiInverse);\n      }\n    }\n    return result;\n  };\n}\nmodule.exports = ReedSolomonDecoder;","map":{"version":3,"names":["GF256Poly","require","GF256","ReedSolomonDecoder","field","decode","received","twoS","poly","syndromeCoefficients","Array","i","length","dataMatrix","noError","eval","evaluateAt","exp","syndrome","sigmaOmega","runEuclideanAlgorithm","buildMonomial","sigma","omega","errorLocations","findErrorLocations","errorMagnitudes","findErrorMagnitudes","position","log","addOrSubtract","a","b","R","Degree","temp","rLast","r","sLast","One","s","Zero","tLast","t","Math","floor","rLastLast","sLastLast","tLastLast","q","denominatorLeadingTerm","getCoefficient","dltInverse","inverse","degreeDiff","scale","multiply","multiplyByMonomial","multiply1","sigmaTildeAtZero","multiply2","errorLocator","numErrors","result","e","errorEvaluator","xiInverse","denominator","j","module","exports"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/jsqrcode/src/rsdecoder.js"],"sourcesContent":["/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\r\n\r\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\nvar GF256Poly = require('./gf256poly');\r\nvar GF256 = require('./gf256');\r\n\r\nfunction ReedSolomonDecoder(field)\r\n{\r\n  this.field = field;\r\n  this.decode=function(received,  twoS)\r\n  {\r\n      var poly = new GF256Poly(this.field, received);\r\n      var syndromeCoefficients = new Array(twoS);\r\n      for(var i=0;i<syndromeCoefficients.length;i++)syndromeCoefficients[i]=0;\r\n      var dataMatrix = false;//this.field.Equals(GF256.DATA_MATRIX_FIELD);\r\n      var noError = true;\r\n      for (var i = 0; i < twoS; i++)\r\n      {\r\n        // Thanks to sanfordsquires for this fix:\r\n        var eval = poly.evaluateAt(this.field.exp(dataMatrix?i + 1:i));\r\n        syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;\r\n        if (eval != 0)\r\n        {\r\n          noError = false;\r\n        }\r\n      }\r\n      if (noError)\r\n      {\r\n        return ;\r\n      }\r\n      var syndrome = new GF256Poly(this.field, syndromeCoefficients);\r\n      var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);\r\n      var sigma = sigmaOmega[0];\r\n      var omega = sigmaOmega[1];\r\n      var errorLocations = this.findErrorLocations(sigma);\r\n      var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);\r\n      for (var i = 0; i < errorLocations.length; i++)\r\n      {\r\n        var position = received.length - 1 - this.field.log(errorLocations[i]);\r\n        if (position < 0)\r\n        {\r\n          throw \"ReedSolomonException Bad error location\";\r\n        }\r\n        received[position] = GF256.addOrSubtract(received[position], errorMagnitudes[i]);\r\n      }\r\n  }\r\n  \r\n  this.runEuclideanAlgorithm=function( a,  b,  R)\r\n    {\r\n      // Assume a's degree is >= b's\r\n      if (a.Degree < b.Degree)\r\n      {\r\n        var temp = a;\r\n        a = b;\r\n        b = temp;\r\n      }\r\n      \r\n      var rLast = a;\r\n      var r = b;\r\n      var sLast = this.field.One;\r\n      var s = this.field.Zero;\r\n      var tLast = this.field.Zero;\r\n      var t = this.field.One;\r\n      \r\n      // Run Euclidean algorithm until r's degree is less than R/2\r\n      while (r.Degree >= Math.floor(R / 2))\r\n      {\r\n        var rLastLast = rLast;\r\n        var sLastLast = sLast;\r\n        var tLastLast = tLast;\r\n        rLast = r;\r\n        sLast = s;\r\n        tLast = t;\r\n        \r\n        // Divide rLastLast by rLast, with quotient in q and remainder in r\r\n        if (rLast.Zero)\r\n        {\r\n          // Oops, Euclidean algorithm already terminated?\r\n          throw \"r_{i-1} was zero\";\r\n        }\r\n        r = rLastLast;\r\n        var q = this.field.Zero;\r\n        var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);\r\n        var dltInverse = this.field.inverse(denominatorLeadingTerm);\r\n        while (r.Degree >= rLast.Degree && !r.Zero)\r\n        {\r\n          var degreeDiff = r.Degree - rLast.Degree;\r\n          var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);\r\n          q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));\r\n          r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\r\n          //r.EXE();\r\n        }\r\n        \r\n        s = q.multiply1(sLast).addOrSubtract(sLastLast);\r\n        t = q.multiply1(tLast).addOrSubtract(tLastLast);\r\n      }\r\n      \r\n      var sigmaTildeAtZero = t.getCoefficient(0);\r\n      if (sigmaTildeAtZero == 0)\r\n      {\r\n        throw \"ReedSolomonException sigmaTilde(0) was zero\";\r\n      }\r\n      \r\n      var inverse = this.field.inverse(sigmaTildeAtZero);\r\n      var sigma = t.multiply2(inverse);\r\n      var omega = r.multiply2(inverse);\r\n      return new Array(sigma, omega);\r\n    }\r\n  this.findErrorLocations=function( errorLocator)\r\n    {\r\n      // This is a direct application of Chien's search\r\n      var numErrors = errorLocator.Degree;\r\n      if (numErrors == 1)\r\n      {\r\n        // shortcut\r\n        return new Array(errorLocator.getCoefficient(1));\r\n      }\r\n      var result = new Array(numErrors);\r\n      var e = 0;\r\n      for (var i = 1; i < 256 && e < numErrors; i++)\r\n      {\r\n        if (errorLocator.evaluateAt(i) == 0)\r\n        {\r\n          result[e] = this.field.inverse(i);\r\n          e++;\r\n        }\r\n      }\r\n      if (e != numErrors)\r\n      {\r\n        throw \"Error locator degree does not match number of roots\";\r\n      }\r\n      return result;\r\n    }\r\n  this.findErrorMagnitudes=function( errorEvaluator,  errorLocations,  dataMatrix)\r\n    {\r\n      // This is directly applying Forney's Formula\r\n      var s = errorLocations.length;\r\n      var result = new Array(s);\r\n      for (var i = 0; i < s; i++)\r\n      {\r\n        var xiInverse = this.field.inverse(errorLocations[i]);\r\n        var denominator = 1;\r\n        for (var j = 0; j < s; j++)\r\n        {\r\n          if (i != j)\r\n          {\r\n            denominator = this.field.multiply(denominator, GF256.addOrSubtract(1, this.field.multiply(errorLocations[j], xiInverse)));\r\n          }\r\n        }\r\n        result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse), this.field.inverse(denominator));\r\n        // Thanks to sanfordsquires for this fix:\r\n        if (dataMatrix)\r\n        {\r\n          result[i] = this.field.multiply(result[i], xiInverse);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n}\r\n\r\nmodule.exports = ReedSolomonDecoder;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}