{"ast":null,"code":"/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\n\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar qrcode = require('./qrcode')();\nvar assert = require('assert');\nvar MIN_SKIP = 3;\nvar MAX_MODULES = 57;\nvar INTEGER_MATH_SHIFT = 8;\nvar CENTER_QUORUM = 2;\nqrcode.orderBestPatterns = function (patterns) {\n  function distance(pattern1, pattern2) {\n    xDiff = pattern1.X - pattern2.X;\n    yDiff = pattern1.Y - pattern2.Y;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n  }\n\n  /// <summary> Returns the z component of the cross product between vectors BC and BA.</summary>\n  function crossProductZ(pointA, pointB, pointC) {\n    var bX = pointB.x;\n    var bY = pointB.y;\n    return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n  }\n\n  // Find distances between pattern centers\n  var zeroOneDistance = distance(patterns[0], patterns[1]);\n  var oneTwoDistance = distance(patterns[1], patterns[2]);\n  var zeroTwoDistance = distance(patterns[0], patterns[2]);\n  var pointA, pointB, pointC;\n  // Assume one closest to other two is B; A and C will just be guesses at first\n  if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n    pointB = patterns[0];\n    pointA = patterns[1];\n    pointC = patterns[2];\n  } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n    pointB = patterns[1];\n    pointA = patterns[0];\n    pointC = patterns[2];\n  } else {\n    pointB = patterns[2];\n    pointA = patterns[0];\n    pointC = patterns[1];\n  }\n\n  // Use cross product to figure out whether A and C are correct or flipped.\n  // This asks whether BC x BA has a positive z component, which is the arrangement\n  // we want for A, B, C. If it's negative, then we've got it flipped around and\n  // should swap A and C.\n  if (crossProductZ(pointA, pointB, pointC) < 0.0) {\n    var temp = pointA;\n    pointA = pointC;\n    pointC = temp;\n  }\n  patterns[0] = pointA;\n  patterns[1] = pointB;\n  patterns[2] = pointC;\n};\nfunction FinderPattern(posX, posY, estimatedModuleSize) {\n  this.x = posX;\n  this.y = posY;\n  this.count = 1;\n  this.estimatedModuleSize = estimatedModuleSize;\n  this.__defineGetter__(\"EstimatedModuleSize\", function () {\n    return this.estimatedModuleSize;\n  });\n  this.__defineGetter__(\"Count\", function () {\n    return this.count;\n  });\n  this.__defineGetter__(\"X\", function () {\n    return this.x;\n  });\n  this.__defineGetter__(\"Y\", function () {\n    return this.y;\n  });\n  this.incrementCount = function () {\n    this.count++;\n  };\n  this.aboutEquals = function (moduleSize, i, j) {\n    if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {\n      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n      return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\n    }\n    return false;\n  };\n}\nfunction FinderPatternInfo(patternCenters) {\n  this.bottomLeft = patternCenters[0];\n  this.topLeft = patternCenters[1];\n  this.topRight = patternCenters[2];\n  this.__defineGetter__(\"BottomLeft\", function () {\n    return this.bottomLeft;\n  });\n  this.__defineGetter__(\"TopLeft\", function () {\n    return this.topLeft;\n  });\n  this.__defineGetter__(\"TopRight\", function () {\n    return this.topRight;\n  });\n}\nfunction FinderPatternFinder() {\n  this.image = null;\n  this.possibleCenters = [];\n  this.hasSkipped = false;\n  this.crossCheckStateCount = new Array(0, 0, 0, 0, 0);\n  this.resultPointCallback = null;\n  this.__defineGetter__(\"CrossCheckStateCount\", function () {\n    this.crossCheckStateCount[0] = 0;\n    this.crossCheckStateCount[1] = 0;\n    this.crossCheckStateCount[2] = 0;\n    this.crossCheckStateCount[3] = 0;\n    this.crossCheckStateCount[4] = 0;\n    return this.crossCheckStateCount;\n  });\n  this.foundPatternCross = function (stateCount) {\n    var totalModuleSize = 0;\n    for (var i = 0; i < 5; i++) {\n      var count = stateCount[i];\n      if (count == 0) {\n        return false;\n      }\n      totalModuleSize += count;\n    }\n    if (totalModuleSize < 7) {\n      return false;\n    }\n    var moduleSize = Math.floor((totalModuleSize << INTEGER_MATH_SHIFT) / 7);\n    var maxVariance = Math.floor(moduleSize / 2);\n    // Allow less than 50% variance from 1-1-3-1-1 proportions\n    return Math.abs(moduleSize - (stateCount[0] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[1] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(3 * moduleSize - (stateCount[2] << INTEGER_MATH_SHIFT)) < 3 * maxVariance && Math.abs(moduleSize - (stateCount[3] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[4] << INTEGER_MATH_SHIFT)) < maxVariance;\n  };\n  this.centerFromEnd = function (stateCount, end) {\n    return end - stateCount[4] - stateCount[3] - stateCount[2] / 2.0;\n  };\n  this.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {\n    var image = this.image;\n    var maxI = qrcode.height;\n    var stateCount = this.CrossCheckStateCount;\n\n    // Start counting up from center\n    var i = startI;\n    while (i >= 0 && image[centerJ + i * qrcode.width]) {\n      stateCount[2]++;\n      i--;\n    }\n    if (i < 0) {\n      return NaN;\n    }\n    while (i >= 0 && !image[centerJ + i * qrcode.width] && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i >= 0 && image[centerJ + i * qrcode.width] && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    }\n\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image[centerJ + i * qrcode.width]) {\n      stateCount[2]++;\n      i++;\n    }\n    if (i == maxI) {\n      return NaN;\n    }\n    while (i < maxI && !image[centerJ + i * qrcode.width] && stateCount[3] < maxCount) {\n      stateCount[3]++;\n      i++;\n    }\n    if (i == maxI || stateCount[3] >= maxCount) {\n      return NaN;\n    }\n    while (i < maxI && image[centerJ + i * qrcode.width] && stateCount[4] < maxCount) {\n      stateCount[4]++;\n      i++;\n    }\n    if (stateCount[4] >= maxCount) {\n      return NaN;\n    }\n\n    // If we found a finder-pattern-like section, but its size is more than 40% different than\n    // the original, assume it's a false positive\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n      return NaN;\n    }\n    return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;\n  };\n  this.crossCheckHorizontal = function (startJ, centerI, maxCount, originalStateCountTotal) {\n    var image = this.image;\n    var maxJ = qrcode.width;\n    var stateCount = this.CrossCheckStateCount;\n    var j = startJ;\n    while (j >= 0 && image[j + centerI * qrcode.width]) {\n      stateCount[2]++;\n      j--;\n    }\n    if (j < 0) {\n      return NaN;\n    }\n    while (j >= 0 && !image[j + centerI * qrcode.width] && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      j--;\n    }\n    if (j < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (j >= 0 && image[j + centerI * qrcode.width] && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      j--;\n    }\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    }\n    j = startJ + 1;\n    while (j < maxJ && image[j + centerI * qrcode.width]) {\n      stateCount[2]++;\n      j++;\n    }\n    if (j == maxJ) {\n      return NaN;\n    }\n    while (j < maxJ && !image[j + centerI * qrcode.width] && stateCount[3] < maxCount) {\n      stateCount[3]++;\n      j++;\n    }\n    if (j == maxJ || stateCount[3] >= maxCount) {\n      return NaN;\n    }\n    while (j < maxJ && image[j + centerI * qrcode.width] && stateCount[4] < maxCount) {\n      stateCount[4]++;\n      j++;\n    }\n    if (stateCount[4] >= maxCount) {\n      return NaN;\n    }\n\n    // If we found a finder-pattern-like section, but its size is significantly different than\n    // the original, assume it's a false positive\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n      return NaN;\n    }\n    return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, j) : NaN;\n  };\n  this.handlePossibleCenter = function (stateCount, i, j) {\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n    var centerJ = this.centerFromEnd(stateCount, j); //float\n    var centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal); //float\n    if (!isNaN(centerI)) {\n      // Re-cross check\n      centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);\n      if (!isNaN(centerJ)) {\n        var estimatedModuleSize = stateCountTotal / 7.0;\n        var found = false;\n        var max = this.possibleCenters.length;\n        for (var index = 0; index < max; index++) {\n          var center = this.possibleCenters[index];\n          // Look for about the same center and module size:\n          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n            center.incrementCount();\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          var point = new FinderPattern(centerJ, centerI, estimatedModuleSize);\n          this.possibleCenters.push(point);\n          if (this.resultPointCallback != null) {\n            this.resultPointCallback.foundPossibleResultPoint(point);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  this.selectBestPatterns = function () {\n    var startSize = this.possibleCenters.length;\n    if (startSize < 3) {\n      // Couldn't find enough finder patterns\n      throw new Error(\"Couldn't find enough finder patterns\");\n    }\n\n    // Filter outlier possibilities whose module size is too different\n    if (startSize > 3) {\n      // But we can only afford to do so if we have at least 4 possibilities to choose from\n      var totalModuleSize = 0.0;\n      for (var i = 0; i < startSize; i++) {\n        totalModuleSize += this.possibleCenters[i].EstimatedModuleSize;\n      }\n      var average = totalModuleSize / startSize;\n      for (var i = 0; i < this.possibleCenters.length && this.possibleCenters.length > 3; i++) {\n        var pattern = this.possibleCenters[i];\n        if (Math.abs(pattern.EstimatedModuleSize - average) > 0.2 * average) {\n          this.possibleCenters.remove(i);\n          i--;\n        }\n      }\n    }\n    if (this.possibleCenters.Count > 3) {\n      // Throw away all but those first size candidate points we found.\n      //Collections.insertionSort(possibleCenters, new CenterComparator());\n      //SupportClass.SetCapacity(possibleCenters, 3);\n    }\n    return new Array(this.possibleCenters[0], this.possibleCenters[1], this.possibleCenters[2]);\n  };\n  this.findRowSkip = function () {\n    var max = this.possibleCenters.length;\n    if (max <= 1) {\n      return 0;\n    }\n    var firstConfirmedCenter = null;\n    for (var i = 0; i < max; i++) {\n      var center = this.possibleCenters[i];\n      if (center.Count >= CENTER_QUORUM) {\n        if (firstConfirmedCenter == null) {\n          firstConfirmedCenter = center;\n        } else {\n          // We have two confirmed centers\n          // How far down can we skip before resuming looking for the next\n          // pattern? In the worst case, only the difference between the\n          // difference in the x / y coordinates of the two centers.\n          // This is the case where you find top left last.\n          this.hasSkipped = true;\n          return Math.floor((Math.abs(firstConfirmedCenter.X - center.X) - Math.abs(firstConfirmedCenter.Y - center.Y)) / 2);\n        }\n      }\n    }\n    return 0;\n  };\n  this.haveMultiplyConfirmedCenters = function () {\n    var confirmedCount = 0;\n    var totalModuleSize = 0.0;\n    var max = this.possibleCenters.length;\n    for (var i = 0; i < max; i++) {\n      var pattern = this.possibleCenters[i];\n      if (pattern.Count >= CENTER_QUORUM) {\n        confirmedCount++;\n        totalModuleSize += pattern.EstimatedModuleSize;\n      }\n    }\n    if (confirmedCount < 3) {\n      return false;\n    }\n    // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n    // and that we need to keep looking. We detect this by asking if the estimated module sizes\n    // vary too much. We arbitrarily say that when the total deviation from average exceeds\n    // 5% of the total module size estimates, it's too much.\n    var average = totalModuleSize / max;\n    var totalDeviation = 0.0;\n    for (var i = 0; i < max; i++) {\n      pattern = this.possibleCenters[i];\n      totalDeviation += Math.abs(pattern.EstimatedModuleSize - average);\n    }\n    return totalDeviation <= 0.05 * totalModuleSize;\n  };\n  this.findFinderPattern = function (image) {\n    var tryHarder = false;\n    this.image = image;\n    var maxI = qrcode.height;\n    var maxJ = qrcode.width;\n    var iSkip = Math.floor(3 * maxI / (4 * MAX_MODULES));\n    if (iSkip < MIN_SKIP || tryHarder) {\n      iSkip = MIN_SKIP;\n    }\n    var done = false;\n    var stateCount = new Array(5);\n    for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {\n      // Get a row of black/white values\n      stateCount[0] = 0;\n      stateCount[1] = 0;\n      stateCount[2] = 0;\n      stateCount[3] = 0;\n      stateCount[4] = 0;\n      var currentState = 0;\n      for (var j = 0; j < maxJ; j++) {\n        if (image[j + i * qrcode.width]) {\n          // Black pixel\n          if ((currentState & 1) == 1) {\n            // Counting white pixels\n            currentState++;\n          }\n          stateCount[currentState]++;\n        } else {\n          // White pixel\n          if ((currentState & 1) == 0) {\n            // Counting black pixels\n            if (currentState == 4) {\n              // A winner?\n              if (this.foundPatternCross(stateCount)) {\n                // Yes\n                var confirmed = this.handlePossibleCenter(stateCount, i, j);\n                if (confirmed) {\n                  // Start examining every other line. Checking each line turned out to be too\n                  // expensive and didn't improve performance.\n                  iSkip = 2;\n                  if (this.hasSkipped) {\n                    done = this.haveMultiplyConfirmedCenters();\n                  } else {\n                    var rowSkip = this.findRowSkip();\n                    if (rowSkip > stateCount[2]) {\n                      // Skip rows between row of lower confirmed center\n                      // and top of presumed third confirmed center\n                      // but back up a bit to get a full chance of detecting\n                      // it, entire width of center of finder pattern\n\n                      // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                      // of pattern we saw) to be conservative, and also back off by iSkip which\n                      // is about to be re-added\n                      i += rowSkip - stateCount[2] - iSkip;\n                      j = maxJ - 1;\n                    }\n                  }\n                } else {\n                  // Advance to next black pixel\n                  do {\n                    j++;\n                  } while (j < maxJ && !image[j + i * qrcode.width]);\n                  j--; // back up to that last white pixel\n                }\n                // Clear state to start looking again\n                currentState = 0;\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                stateCount[3] = 0;\n                stateCount[4] = 0;\n              } else {\n                // No, shift counts back by two\n                stateCount[0] = stateCount[2];\n                stateCount[1] = stateCount[3];\n                stateCount[2] = stateCount[4];\n                stateCount[3] = 1;\n                stateCount[4] = 0;\n                currentState = 3;\n              }\n            } else {\n              stateCount[++currentState]++;\n            }\n          } else {\n            // Counting white pixels\n            stateCount[currentState]++;\n          }\n        }\n      }\n      if (this.foundPatternCross(stateCount)) {\n        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n        if (confirmed) {\n          iSkip = stateCount[0];\n          if (this.hasSkipped) {\n            // Found a third one\n            done = haveMultiplyConfirmedCenters();\n          }\n        }\n      }\n    }\n    var patternInfo = this.selectBestPatterns();\n    qrcode.orderBestPatterns(patternInfo);\n    return new FinderPatternInfo(patternInfo);\n  };\n}\nmodule.exports = FinderPatternFinder;","map":{"version":3,"names":["qrcode","require","assert","MIN_SKIP","MAX_MODULES","INTEGER_MATH_SHIFT","CENTER_QUORUM","orderBestPatterns","patterns","distance","pattern1","pattern2","xDiff","X","yDiff","Y","Math","sqrt","crossProductZ","pointA","pointB","pointC","bX","x","bY","y","zeroOneDistance","oneTwoDistance","zeroTwoDistance","temp","FinderPattern","posX","posY","estimatedModuleSize","count","__defineGetter__","incrementCount","aboutEquals","moduleSize","i","j","abs","moduleSizeDiff","FinderPatternInfo","patternCenters","bottomLeft","topLeft","topRight","FinderPatternFinder","image","possibleCenters","hasSkipped","crossCheckStateCount","Array","resultPointCallback","foundPatternCross","stateCount","totalModuleSize","floor","maxVariance","centerFromEnd","end","crossCheckVertical","startI","centerJ","maxCount","originalStateCountTotal","maxI","height","CrossCheckStateCount","width","NaN","stateCountTotal","crossCheckHorizontal","startJ","centerI","maxJ","handlePossibleCenter","isNaN","found","max","length","index","center","point","push","foundPossibleResultPoint","selectBestPatterns","startSize","Error","EstimatedModuleSize","average","pattern","remove","Count","findRowSkip","firstConfirmedCenter","haveMultiplyConfirmedCenters","confirmedCount","totalDeviation","findFinderPattern","tryHarder","iSkip","done","currentState","confirmed","rowSkip","patternInfo","module","exports"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/jsqrcode/src/findpat.js"],"sourcesContent":["/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\r\n\r\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\nvar qrcode = require('./qrcode')();\r\nvar assert = require('assert');\r\n\r\n\r\nvar MIN_SKIP = 3;\r\nvar MAX_MODULES = 57;\r\nvar INTEGER_MATH_SHIFT = 8;\r\nvar CENTER_QUORUM = 2;\r\n\r\nqrcode.orderBestPatterns = function(patterns)\r\n    {\r\n      \r\n      function distance( pattern1,  pattern2)\r\n      {\r\n        xDiff = pattern1.X - pattern2.X;\r\n        yDiff = pattern1.Y - pattern2.Y;\r\n        return  Math.sqrt( (xDiff * xDiff + yDiff * yDiff));\r\n      }\r\n      \r\n      /// <summary> Returns the z component of the cross product between vectors BC and BA.</summary>\r\n      function crossProductZ( pointA,  pointB,  pointC)\r\n      {\r\n        var bX = pointB.x;\r\n        var bY = pointB.y;\r\n        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\r\n      }\r\n\r\n      \r\n      // Find distances between pattern centers\r\n      var zeroOneDistance = distance(patterns[0], patterns[1]);\r\n      var oneTwoDistance = distance(patterns[1], patterns[2]);\r\n      var zeroTwoDistance = distance(patterns[0], patterns[2]);\r\n      \r\n      var pointA, pointB, pointC;\r\n      // Assume one closest to other two is B; A and C will just be guesses at first\r\n      if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance)\r\n      {\r\n        pointB = patterns[0];\r\n        pointA = patterns[1];\r\n        pointC = patterns[2];\r\n      }\r\n      else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance)\r\n      {\r\n        pointB = patterns[1];\r\n        pointA = patterns[0];\r\n        pointC = patterns[2];\r\n      }\r\n      else\r\n      {\r\n        pointB = patterns[2];\r\n        pointA = patterns[0];\r\n        pointC = patterns[1];\r\n      }\r\n      \r\n      // Use cross product to figure out whether A and C are correct or flipped.\r\n      // This asks whether BC x BA has a positive z component, which is the arrangement\r\n      // we want for A, B, C. If it's negative, then we've got it flipped around and\r\n      // should swap A and C.\r\n      if (crossProductZ(pointA, pointB, pointC) < 0.0)\r\n      {\r\n        var temp = pointA;\r\n        pointA = pointC;\r\n        pointC = temp;\r\n      }\r\n      \r\n      patterns[0] = pointA;\r\n      patterns[1] = pointB;\r\n      patterns[2] = pointC;\r\n    }\r\n\r\n\r\nfunction FinderPattern(posX, posY,  estimatedModuleSize)\r\n{\r\n  this.x=posX;\r\n  this.y=posY;\r\n  this.count = 1;\r\n  this.estimatedModuleSize = estimatedModuleSize;\r\n  \r\n  this.__defineGetter__(\"EstimatedModuleSize\", function()\r\n  {\r\n    return this.estimatedModuleSize;\r\n  }); \r\n  this.__defineGetter__(\"Count\", function()\r\n  {\r\n    return this.count;\r\n  });\r\n  this.__defineGetter__(\"X\", function()\r\n  {\r\n    return this.x;\r\n  });\r\n  this.__defineGetter__(\"Y\", function()\r\n  {\r\n    return this.y;\r\n  });\r\n  this.incrementCount = function()\r\n  {\r\n    this.count++;\r\n  }\r\n  this.aboutEquals=function( moduleSize,  i,  j)\r\n    {\r\n      if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize)\r\n      {\r\n        var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\r\n        return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\r\n      }\r\n      return false;\r\n    }\r\n  \r\n}\r\n\r\nfunction FinderPatternInfo(patternCenters)\r\n{\r\n  this.bottomLeft = patternCenters[0];\r\n  this.topLeft = patternCenters[1];\r\n  this.topRight = patternCenters[2];\r\n  this.__defineGetter__(\"BottomLeft\", function()\r\n  {\r\n    return this.bottomLeft;\r\n  }); \r\n  this.__defineGetter__(\"TopLeft\", function()\r\n  {\r\n    return this.topLeft;\r\n  }); \r\n  this.__defineGetter__(\"TopRight\", function()\r\n  {\r\n    return this.topRight;\r\n  }); \r\n}\r\n\r\nfunction FinderPatternFinder()\r\n{\r\n  this.image=null;\r\n  this.possibleCenters = [];\r\n  this.hasSkipped = false;\r\n  this.crossCheckStateCount = new Array(0,0,0,0,0);\r\n  this.resultPointCallback = null;\r\n  \r\n  this.__defineGetter__(\"CrossCheckStateCount\", function()\r\n  {\r\n    this.crossCheckStateCount[0] = 0;\r\n    this.crossCheckStateCount[1] = 0;\r\n    this.crossCheckStateCount[2] = 0;\r\n    this.crossCheckStateCount[3] = 0;\r\n    this.crossCheckStateCount[4] = 0;\r\n    return this.crossCheckStateCount;\r\n  }); \r\n  \r\n  this.foundPatternCross=function( stateCount)\r\n    {\r\n      var totalModuleSize = 0;\r\n      for (var i = 0; i < 5; i++)\r\n      {\r\n        var count = stateCount[i];\r\n        if (count == 0)\r\n        {\r\n          return false;\r\n        }\r\n        totalModuleSize += count;\r\n      }\r\n      if (totalModuleSize < 7)\r\n      {\r\n        return false;\r\n      }\r\n      var moduleSize = Math.floor((totalModuleSize << INTEGER_MATH_SHIFT) / 7);\r\n      var maxVariance = Math.floor(moduleSize / 2);\r\n      // Allow less than 50% variance from 1-1-3-1-1 proportions\r\n      return Math.abs(moduleSize - (stateCount[0] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[1] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(3 * moduleSize - (stateCount[2] << INTEGER_MATH_SHIFT)) < 3 * maxVariance && Math.abs(moduleSize - (stateCount[3] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[4] << INTEGER_MATH_SHIFT)) < maxVariance;\r\n    }\r\n  this.centerFromEnd=function( stateCount,  end)\r\n    {\r\n      return  (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;\r\n    }\r\n  this.crossCheckVertical=function( startI,  centerJ,  maxCount,  originalStateCountTotal)\r\n    {\r\n      var image = this.image;\r\n      \r\n      var maxI = qrcode.height;\r\n      var stateCount = this.CrossCheckStateCount;\r\n      \r\n      // Start counting up from center\r\n      var i = startI;\r\n      while (i >= 0 && image[centerJ + i*qrcode.width])\r\n      {\r\n        stateCount[2]++;\r\n        i--;\r\n      }\r\n      if (i < 0)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (i >= 0 && !image[centerJ +i*qrcode.width] && stateCount[1] <= maxCount)\r\n      {\r\n        stateCount[1]++;\r\n        i--;\r\n      }\r\n      // If already too many modules in this state or ran off the edge:\r\n      if (i < 0 || stateCount[1] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (i >= 0 && image[centerJ + i*qrcode.width] && stateCount[0] <= maxCount)\r\n      {\r\n        stateCount[0]++;\r\n        i--;\r\n      }\r\n      if (stateCount[0] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      // Now also count down from center\r\n      i = startI + 1;\r\n      while (i < maxI && image[centerJ +i*qrcode.width])\r\n      {\r\n        stateCount[2]++;\r\n        i++;\r\n      }\r\n      if (i == maxI)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (i < maxI && !image[centerJ + i*qrcode.width] && stateCount[3] < maxCount)\r\n      {\r\n        stateCount[3]++;\r\n        i++;\r\n      }\r\n      if (i == maxI || stateCount[3] >= maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (i < maxI && image[centerJ + i*qrcode.width] && stateCount[4] < maxCount)\r\n      {\r\n        stateCount[4]++;\r\n        i++;\r\n      }\r\n      if (stateCount[4] >= maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      // If we found a finder-pattern-like section, but its size is more than 40% different than\r\n      // the original, assume it's a false positive\r\n      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\r\n      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, i):NaN;\r\n    }\r\n  this.crossCheckHorizontal=function( startJ,  centerI,  maxCount, originalStateCountTotal)\r\n    {\r\n      var image = this.image;\r\n      \r\n      var maxJ = qrcode.width;\r\n      var stateCount = this.CrossCheckStateCount;\r\n      \r\n      var j = startJ;\r\n      while (j >= 0 && image[j+ centerI*qrcode.width])\r\n      {\r\n        stateCount[2]++;\r\n        j--;\r\n      }\r\n      if (j < 0)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (j >= 0 && !image[j+ centerI*qrcode.width] && stateCount[1] <= maxCount)\r\n      {\r\n        stateCount[1]++;\r\n        j--;\r\n      }\r\n      if (j < 0 || stateCount[1] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (j >= 0 && image[j+ centerI*qrcode.width] && stateCount[0] <= maxCount)\r\n      {\r\n        stateCount[0]++;\r\n        j--;\r\n      }\r\n      if (stateCount[0] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      j = startJ + 1;\r\n      while (j < maxJ && image[j+ centerI*qrcode.width])\r\n      {\r\n        stateCount[2]++;\r\n        j++;\r\n      }\r\n      if (j == maxJ)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (j < maxJ && !image[j+ centerI*qrcode.width] && stateCount[3] < maxCount)\r\n      {\r\n        stateCount[3]++;\r\n        j++;\r\n      }\r\n      if (j == maxJ || stateCount[3] >= maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (j < maxJ && image[j+ centerI*qrcode.width] && stateCount[4] < maxCount)\r\n      {\r\n        stateCount[4]++;\r\n        j++;\r\n      }\r\n      if (stateCount[4] >= maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      // If we found a finder-pattern-like section, but its size is significantly different than\r\n      // the original, assume it's a false positive\r\n      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\r\n      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, j):NaN;\r\n    }\r\n  this.handlePossibleCenter = function( stateCount,  i,  j)\r\n    {\r\n      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\r\n      var centerJ = this.centerFromEnd(stateCount, j); //float\r\n      var centerI = this.crossCheckVertical(i, Math.floor( centerJ), stateCount[2], stateCountTotal); //float\r\n      if (!isNaN(centerI))\r\n      {\r\n        // Re-cross check\r\n        centerJ = this.crossCheckHorizontal(Math.floor( centerJ), Math.floor( centerI), stateCount[2], stateCountTotal);\r\n        if (!isNaN(centerJ))\r\n        {\r\n          var estimatedModuleSize =   stateCountTotal / 7.0;\r\n          var found = false;\r\n          var max = this.possibleCenters.length;\r\n          for (var index = 0; index < max; index++)\r\n          {\r\n            var center = this.possibleCenters[index];\r\n            // Look for about the same center and module size:\r\n            if (center.aboutEquals(estimatedModuleSize, centerI, centerJ))\r\n            {\r\n              center.incrementCount();\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found)\r\n          {\r\n            var point = new FinderPattern(centerJ, centerI, estimatedModuleSize);\r\n            this.possibleCenters.push(point);\r\n            if (this.resultPointCallback != null)\r\n            {\r\n              this.resultPointCallback.foundPossibleResultPoint(point);\r\n            }\r\n          }\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n    \r\n  this.selectBestPatterns = function()\r\n    {\r\n      \r\n      var startSize = this.possibleCenters.length;\r\n      if (startSize < 3)\r\n      {\r\n        // Couldn't find enough finder patterns\r\n        throw new Error(\"Couldn't find enough finder patterns\");\r\n      }\r\n      \r\n      // Filter outlier possibilities whose module size is too different\r\n      if (startSize > 3)\r\n      {\r\n        // But we can only afford to do so if we have at least 4 possibilities to choose from\r\n        var totalModuleSize = 0.0;\r\n        for (var i = 0; i < startSize; i++)\r\n        {\r\n          totalModuleSize +=  this.possibleCenters[i].EstimatedModuleSize;\r\n        }\r\n        var average = totalModuleSize /  startSize;\r\n        for (var i = 0; i < this.possibleCenters.length && this.possibleCenters.length > 3; i++)\r\n        {\r\n          var pattern =  this.possibleCenters[i];\r\n          if (Math.abs(pattern.EstimatedModuleSize - average) > 0.2 * average)\r\n          {\r\n            this.possibleCenters.remove(i);\r\n            i--;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (this.possibleCenters.Count > 3)\r\n      {\r\n        // Throw away all but those first size candidate points we found.\r\n        //Collections.insertionSort(possibleCenters, new CenterComparator());\r\n        //SupportClass.SetCapacity(possibleCenters, 3);\r\n      }\r\n      \r\n      return new Array( this.possibleCenters[0],  this.possibleCenters[1],  this.possibleCenters[2]);\r\n    }\r\n    \r\n  this.findRowSkip=function()\r\n    {\r\n      var max = this.possibleCenters.length;\r\n      if (max <= 1)\r\n      {\r\n        return 0;\r\n      }\r\n      var firstConfirmedCenter = null;\r\n      for (var i = 0; i < max; i++)\r\n      {\r\n        var center =  this.possibleCenters[i];\r\n        if (center.Count >= CENTER_QUORUM)\r\n        {\r\n          if (firstConfirmedCenter == null)\r\n          {\r\n            firstConfirmedCenter = center;\r\n          }\r\n          else\r\n          {\r\n            // We have two confirmed centers\r\n            // How far down can we skip before resuming looking for the next\r\n            // pattern? In the worst case, only the difference between the\r\n            // difference in the x / y coordinates of the two centers.\r\n            // This is the case where you find top left last.\r\n            this.hasSkipped = true;\r\n            return Math.floor ((Math.abs(firstConfirmedCenter.X - center.X) - Math.abs(firstConfirmedCenter.Y - center.Y)) / 2);\r\n          }\r\n        }\r\n      }\r\n      return 0;\r\n    }\r\n  \r\n  this.haveMultiplyConfirmedCenters=function()\r\n    {\r\n      var confirmedCount = 0;\r\n      var totalModuleSize = 0.0;\r\n      var max = this.possibleCenters.length;\r\n      for (var i = 0; i < max; i++)\r\n      {\r\n        var pattern =  this.possibleCenters[i];\r\n        if (pattern.Count >= CENTER_QUORUM)\r\n        {\r\n          confirmedCount++;\r\n          totalModuleSize += pattern.EstimatedModuleSize;\r\n        }\r\n      }\r\n      if (confirmedCount < 3)\r\n      {\r\n        return false;\r\n      }\r\n      // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\r\n      // and that we need to keep looking. We detect this by asking if the estimated module sizes\r\n      // vary too much. We arbitrarily say that when the total deviation from average exceeds\r\n      // 5% of the total module size estimates, it's too much.\r\n      var average = totalModuleSize / max;\r\n      var totalDeviation = 0.0;\r\n      for (var i = 0; i < max; i++)\r\n      {\r\n        pattern = this.possibleCenters[i];\r\n        totalDeviation += Math.abs(pattern.EstimatedModuleSize - average);\r\n      }\r\n      return totalDeviation <= 0.05 * totalModuleSize;\r\n    }\r\n    \r\n  this.findFinderPattern = function(image){\r\n    var tryHarder = false;\r\n    this.image = image;\r\n    var maxI = qrcode.height;\r\n    var maxJ = qrcode.width;\r\n    \r\n    var iSkip = Math.floor((3 * maxI) / (4 * MAX_MODULES));\r\n    if (iSkip < MIN_SKIP || tryHarder)\r\n    {\r\n        iSkip = MIN_SKIP;\r\n    }\r\n    \r\n    var done = false;\r\n    \r\n    var stateCount = new Array(5);\r\n    \r\n    for (var i = iSkip - 1; i < maxI && !done; i += iSkip){\r\n      // Get a row of black/white values\r\n      stateCount[0] = 0;\r\n      stateCount[1] = 0;\r\n      stateCount[2] = 0;\r\n      stateCount[3] = 0;\r\n      stateCount[4] = 0;\r\n      var currentState = 0;\r\n      for (var j = 0; j < maxJ; j++)\r\n      {\r\n        if (image[j+i*qrcode.width] )\r\n        {\r\n          // Black pixel\r\n          if ((currentState & 1) == 1)\r\n          {\r\n            // Counting white pixels\r\n            currentState++;\r\n          }\r\n          stateCount[currentState]++;\r\n        }\r\n        else\r\n        {\r\n          // White pixel\r\n          if ((currentState & 1) == 0)\r\n          {\r\n            // Counting black pixels\r\n            if (currentState == 4)\r\n            {\r\n              // A winner?\r\n              if (this.foundPatternCross(stateCount))\r\n              {\r\n                // Yes\r\n                var confirmed = this.handlePossibleCenter(stateCount, i, j);\r\n                if (confirmed)\r\n                {\r\n                  // Start examining every other line. Checking each line turned out to be too\r\n                  // expensive and didn't improve performance.\r\n                  iSkip = 2;\r\n                  if (this.hasSkipped)\r\n                  {\r\n                    done = this.haveMultiplyConfirmedCenters();\r\n                  }\r\n                  else\r\n                  {\r\n                    var rowSkip = this.findRowSkip();\r\n                    if (rowSkip > stateCount[2])\r\n                    {\r\n                      // Skip rows between row of lower confirmed center\r\n                      // and top of presumed third confirmed center\r\n                      // but back up a bit to get a full chance of detecting\r\n                      // it, entire width of center of finder pattern\r\n                      \r\n                      // Skip by rowSkip, but back off by stateCount[2] (size of last center\r\n                      // of pattern we saw) to be conservative, and also back off by iSkip which\r\n                      // is about to be re-added\r\n                      i += rowSkip - stateCount[2] - iSkip;\r\n                      j = maxJ - 1;\r\n                    }\r\n                  }\r\n                }\r\n                else\r\n                {\r\n                  // Advance to next black pixel\r\n                  do \r\n                  {\r\n                    j++;\r\n                  }\r\n                  while (j < maxJ && !image[j + i*qrcode.width]);\r\n                  j--; // back up to that last white pixel\r\n                }\r\n                // Clear state to start looking again\r\n                currentState = 0;\r\n                stateCount[0] = 0;\r\n                stateCount[1] = 0;\r\n                stateCount[2] = 0;\r\n                stateCount[3] = 0;\r\n                stateCount[4] = 0;\r\n              }\r\n              else\r\n              {\r\n                // No, shift counts back by two\r\n                stateCount[0] = stateCount[2];\r\n                stateCount[1] = stateCount[3];\r\n                stateCount[2] = stateCount[4];\r\n                stateCount[3] = 1;\r\n                stateCount[4] = 0;\r\n                currentState = 3;\r\n              }\r\n            }\r\n            else\r\n            {\r\n              stateCount[++currentState]++;\r\n            }\r\n          }\r\n          else\r\n          {\r\n            // Counting white pixels\r\n            stateCount[currentState]++;\r\n          }\r\n        }\r\n      }\r\n      if (this.foundPatternCross(stateCount))\r\n      {\r\n        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\r\n        if (confirmed)\r\n        {\r\n          iSkip = stateCount[0];\r\n          if (this.hasSkipped)\r\n          {\r\n            // Found a third one\r\n            done = haveMultiplyConfirmedCenters();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    var patternInfo = this.selectBestPatterns();\r\n    qrcode.orderBestPatterns(patternInfo);\r\n    \r\n    return new FinderPatternInfo(patternInfo);\r\n  };\r\n}\r\n\r\nmodule.exports = FinderPatternFinder;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}