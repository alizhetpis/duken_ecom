{"ast":null,"code":"/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\n\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar qrcode = require('./qrcode')();\nfunction AlignmentPattern(posX, posY, estimatedModuleSize) {\n  this.x = posX;\n  this.y = posY;\n  this.count = 1;\n  this.estimatedModuleSize = estimatedModuleSize;\n  this.__defineGetter__(\"EstimatedModuleSize\", function () {\n    return this.estimatedModuleSize;\n  });\n  this.__defineGetter__(\"Count\", function () {\n    return this.count;\n  });\n  this.__defineGetter__(\"X\", function () {\n    return Math.floor(this.x);\n  });\n  this.__defineGetter__(\"Y\", function () {\n    return Math.floor(this.y);\n  });\n  this.incrementCount = function () {\n    this.count++;\n  };\n  this.aboutEquals = function (moduleSize, i, j) {\n    if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {\n      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n      return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\n    }\n    return false;\n  };\n}\nfunction AlignmentPatternFinder(image, startX, startY, width, height, moduleSize, resultPointCallback) {\n  this.image = image;\n  this.possibleCenters = new Array();\n  this.startX = startX;\n  this.startY = startY;\n  this.width = width;\n  this.height = height;\n  this.moduleSize = moduleSize;\n  this.crossCheckStateCount = new Array(0, 0, 0);\n  this.resultPointCallback = resultPointCallback;\n  this.centerFromEnd = function (stateCount, end) {\n    return end - stateCount[2] - stateCount[1] / 2.0;\n  };\n  this.foundPatternCross = function (stateCount) {\n    var moduleSize = this.moduleSize;\n    var maxVariance = moduleSize / 2.0;\n    for (var i = 0; i < 3; i++) {\n      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n        return false;\n      }\n    }\n    return true;\n  };\n  this.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {\n    var image = this.image;\n    var maxI = qrcode.height;\n    var stateCount = this.crossCheckStateCount;\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0;\n\n    // Start counting up from center\n    var i = startI;\n    while (i >= 0 && image[centerJ + i * qrcode.width] && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i >= 0 && !image[centerJ + i * qrcode.width] && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    }\n\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image[centerJ + i * qrcode.width] && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i++;\n    }\n    if (i == maxI || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i < maxI && !image[centerJ + i * qrcode.width] && stateCount[2] <= maxCount) {\n      stateCount[2]++;\n      i++;\n    }\n    if (stateCount[2] > maxCount) {\n      return NaN;\n    }\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n      return NaN;\n    }\n    return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;\n  };\n  this.handlePossibleCenter = function (stateCount, i, j) {\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    var centerJ = this.centerFromEnd(stateCount, j);\n    var centerI = this.crossCheckVertical(i, Math.floor(centerJ), 2 * stateCount[1], stateCountTotal);\n    if (!isNaN(centerI)) {\n      var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n      var max = this.possibleCenters.length;\n      for (var index = 0; index < max; index++) {\n        var center = this.possibleCenters[index];\n        // Look for about the same center and module size:\n        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n          return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n        }\n      }\n      // Hadn't found this before; save it\n      var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n      this.possibleCenters.push(point);\n      if (this.resultPointCallback != null) {\n        this.resultPointCallback.foundPossibleResultPoint(point);\n      }\n    }\n    return null;\n  };\n  this.find = function () {\n    var startX = this.startX;\n    var height = this.height;\n    var maxJ = startX + width;\n    var middleI = startY + (height >> 1);\n    // We are looking for black/white/black modules in 1:1:1 ratio;\n    // this tracks the number of black/white/black modules seen so far\n    var stateCount = new Array(0, 0, 0);\n    for (var iGen = 0; iGen < height; iGen++) {\n      // Search from middle outwards\n      var i = middleI + ((iGen & 0x01) == 0 ? iGen + 1 >> 1 : -(iGen + 1 >> 1));\n      stateCount[0] = 0;\n      stateCount[1] = 0;\n      stateCount[2] = 0;\n      var j = startX;\n      // Burn off leading white pixels before anything else; if we start in the middle of\n      // a white run, it doesn't make sense to count its length, since we don't know if the\n      // white run continued to the left of the start point\n      while (j < maxJ && !image[j + qrcode.width * i]) {\n        j++;\n      }\n      var currentState = 0;\n      while (j < maxJ) {\n        if (image[j + i * qrcode.width]) {\n          // Black pixel\n          if (currentState == 1) {\n            // Counting black pixels\n            stateCount[currentState]++;\n          } else {\n            // Counting white pixels\n            if (currentState == 2) {\n              // A winner?\n              if (this.foundPatternCross(stateCount)) {\n                // Yes\n                var confirmed = this.handlePossibleCenter(stateCount, i, j);\n                if (confirmed != null) {\n                  return confirmed;\n                }\n              }\n              stateCount[0] = stateCount[2];\n              stateCount[1] = 1;\n              stateCount[2] = 0;\n              currentState = 1;\n            } else {\n              stateCount[++currentState]++;\n            }\n          }\n        } else {\n          // White pixel\n          if (currentState == 1) {\n            // Counting black pixels\n            currentState++;\n          }\n          stateCount[currentState]++;\n        }\n        j++;\n      }\n      if (this.foundPatternCross(stateCount)) {\n        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n        if (confirmed != null) {\n          return confirmed;\n        }\n      }\n    }\n\n    // Hmm, nothing we saw was observed and confirmed twice. If we had\n    // any guess at all, return it.\n    if (!(this.possibleCenters.length == 0)) {\n      return this.possibleCenters[0];\n    }\n    throw \"Couldn't find enough alignment patterns\";\n  };\n}\nmodule.exports = AlignmentPatternFinder;","map":{"version":3,"names":["qrcode","require","AlignmentPattern","posX","posY","estimatedModuleSize","x","y","count","__defineGetter__","Math","floor","incrementCount","aboutEquals","moduleSize","i","j","abs","moduleSizeDiff","AlignmentPatternFinder","image","startX","startY","width","height","resultPointCallback","possibleCenters","Array","crossCheckStateCount","centerFromEnd","stateCount","end","foundPatternCross","maxVariance","crossCheckVertical","startI","centerJ","maxCount","originalStateCountTotal","maxI","NaN","stateCountTotal","handlePossibleCenter","centerI","isNaN","max","length","index","center","point","push","foundPossibleResultPoint","find","maxJ","middleI","iGen","currentState","confirmed","module","exports"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/jsqrcode/src/alignpat.js"],"sourcesContent":["/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\r\n\r\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\nvar qrcode = require('./qrcode')();\r\n\r\nfunction AlignmentPattern(posX, posY,  estimatedModuleSize)\r\n{\r\n  this.x=posX;\r\n  this.y=posY;\r\n  this.count = 1;\r\n  this.estimatedModuleSize = estimatedModuleSize;\r\n  \r\n  this.__defineGetter__(\"EstimatedModuleSize\", function()\r\n  {\r\n    return this.estimatedModuleSize;\r\n  }); \r\n  this.__defineGetter__(\"Count\", function()\r\n  {\r\n    return this.count;\r\n  });\r\n  this.__defineGetter__(\"X\", function()\r\n  {\r\n    return Math.floor(this.x);\r\n  });\r\n  this.__defineGetter__(\"Y\", function()\r\n  {\r\n    return Math.floor(this.y);\r\n  });\r\n  this.incrementCount = function()\r\n  {\r\n    this.count++;\r\n  }\r\n  this.aboutEquals=function( moduleSize,  i,  j)\r\n    {\r\n      if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize)\r\n      {\r\n        var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\r\n        return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\r\n      }\r\n      return false;\r\n    }\r\n  \r\n}\r\n\r\nfunction AlignmentPatternFinder( image,  startX,  startY,  width,  height,  moduleSize,  resultPointCallback)\r\n{\r\n  this.image = image;\r\n  this.possibleCenters = new Array();\r\n  this.startX = startX;\r\n  this.startY = startY;\r\n  this.width = width;\r\n  this.height = height;\r\n  this.moduleSize = moduleSize;\r\n  this.crossCheckStateCount = new Array(0,0,0);\r\n  this.resultPointCallback = resultPointCallback;\r\n  \r\n  this.centerFromEnd=function(stateCount,  end)\r\n    {\r\n      return  (end - stateCount[2]) - stateCount[1] / 2.0;\r\n    }\r\n  this.foundPatternCross = function(stateCount)\r\n    {\r\n      var moduleSize = this.moduleSize;\r\n      var maxVariance = moduleSize / 2.0;\r\n      for (var i = 0; i < 3; i++)\r\n      {\r\n        if (Math.abs(moduleSize - stateCount[i]) >= maxVariance)\r\n        {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n  this.crossCheckVertical=function( startI,  centerJ,  maxCount,  originalStateCountTotal)\r\n    {\r\n      var image = this.image;\r\n      \r\n      var maxI = qrcode.height;\r\n      var stateCount = this.crossCheckStateCount;\r\n      stateCount[0] = 0;\r\n      stateCount[1] = 0;\r\n      stateCount[2] = 0;\r\n      \r\n      // Start counting up from center\r\n      var i = startI;\r\n      while (i >= 0 && image[centerJ + i*qrcode.width] && stateCount[1] <= maxCount)\r\n      {\r\n        stateCount[1]++;\r\n        i--;\r\n      }\r\n      // If already too many modules in this state or ran off the edge:\r\n      if (i < 0 || stateCount[1] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (i >= 0 && !image[centerJ + i*qrcode.width] && stateCount[0] <= maxCount)\r\n      {\r\n        stateCount[0]++;\r\n        i--;\r\n      }\r\n      if (stateCount[0] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      // Now also count down from center\r\n      i = startI + 1;\r\n      while (i < maxI && image[centerJ + i*qrcode.width] && stateCount[1] <= maxCount)\r\n      {\r\n        stateCount[1]++;\r\n        i++;\r\n      }\r\n      if (i == maxI || stateCount[1] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      while (i < maxI && !image[centerJ + i*qrcode.width] && stateCount[2] <= maxCount)\r\n      {\r\n        stateCount[2]++;\r\n        i++;\r\n      }\r\n      if (stateCount[2] > maxCount)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\r\n      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal)\r\n      {\r\n        return NaN;\r\n      }\r\n      \r\n      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, i):NaN;\r\n    }\r\n    \r\n  this.handlePossibleCenter=function( stateCount,  i,  j)\r\n    {\r\n      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\r\n      var centerJ = this.centerFromEnd(stateCount, j);\r\n      var centerI = this.crossCheckVertical(i, Math.floor (centerJ), 2 * stateCount[1], stateCountTotal);\r\n      if (!isNaN(centerI))\r\n      {\r\n        var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\r\n        var max = this.possibleCenters.length;\r\n        for (var index = 0; index < max; index++)\r\n        {\r\n          var center =  this.possibleCenters[index];\r\n          // Look for about the same center and module size:\r\n          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ))\r\n          {\r\n            return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\r\n          }\r\n        }\r\n        // Hadn't found this before; save it\r\n        var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\r\n        this.possibleCenters.push(point);\r\n        if (this.resultPointCallback != null)\r\n        {\r\n          this.resultPointCallback.foundPossibleResultPoint(point);\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    \r\n  this.find = function()\r\n  {\r\n      var startX = this.startX;\r\n      var height = this.height;\r\n      var maxJ = startX + width;\r\n      var middleI = startY + (height >> 1);\r\n      // We are looking for black/white/black modules in 1:1:1 ratio;\r\n      // this tracks the number of black/white/black modules seen so far\r\n      var stateCount = new Array(0,0,0);\r\n      for (var iGen = 0; iGen < height; iGen++)\r\n      {\r\n        // Search from middle outwards\r\n        var i = middleI + ((iGen & 0x01) == 0?((iGen + 1) >> 1):- ((iGen + 1) >> 1));\r\n        stateCount[0] = 0;\r\n        stateCount[1] = 0;\r\n        stateCount[2] = 0;\r\n        var j = startX;\r\n        // Burn off leading white pixels before anything else; if we start in the middle of\r\n        // a white run, it doesn't make sense to count its length, since we don't know if the\r\n        // white run continued to the left of the start point\r\n        while (j < maxJ && !image[j + qrcode.width* i])\r\n        {\r\n          j++;\r\n        }\r\n        var currentState = 0;\r\n        while (j < maxJ)\r\n        {\r\n          if (image[j + i*qrcode.width])\r\n          {\r\n            // Black pixel\r\n            if (currentState == 1)\r\n            {\r\n              // Counting black pixels\r\n              stateCount[currentState]++;\r\n            }\r\n            else\r\n            {\r\n              // Counting white pixels\r\n              if (currentState == 2)\r\n              {\r\n                // A winner?\r\n                if (this.foundPatternCross(stateCount))\r\n                {\r\n                  // Yes\r\n                  var confirmed = this.handlePossibleCenter(stateCount, i, j);\r\n                  if (confirmed != null)\r\n                  {\r\n                    return confirmed;\r\n                  }\r\n                }\r\n                stateCount[0] = stateCount[2];\r\n                stateCount[1] = 1;\r\n                stateCount[2] = 0;\r\n                currentState = 1;\r\n              }\r\n              else\r\n              {\r\n                stateCount[++currentState]++;\r\n              }\r\n            }\r\n          }\r\n          else\r\n          {\r\n            // White pixel\r\n            if (currentState == 1)\r\n            {\r\n              // Counting black pixels\r\n              currentState++;\r\n            }\r\n            stateCount[currentState]++;\r\n          }\r\n          j++;\r\n        }\r\n        if (this.foundPatternCross(stateCount))\r\n        {\r\n          var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\r\n          if (confirmed != null)\r\n          {\r\n            return confirmed;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Hmm, nothing we saw was observed and confirmed twice. If we had\r\n      // any guess at all, return it.\r\n      if (!(this.possibleCenters.length == 0))\r\n      {\r\n        return  this.possibleCenters[0];\r\n      }\r\n      \r\n      throw \"Couldn't find enough alignment patterns\";\r\n    }\r\n  \r\n}\r\n\r\nmodule.exports = AlignmentPatternFinder"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}