{"ast":null,"code":"/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\n\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar grid = require('./grid');\nvar Version = require('./version');\nvar PerspectiveTransform = require('./perspective-transform');\nvar qrcode = require('./qrcode')();\nvar AlignmentPatternFinder = require('./alignpat');\nvar FinderPatternFinder = require('./findpat');\nfunction DetectorResult(bits, points) {\n  this.bits = bits;\n  this.points = points;\n}\nfunction Detector(image) {\n  this.image = image;\n  this.resultPointCallback = null;\n  this.sizeOfBlackWhiteBlackRun = function (fromX, fromY, toX, toY) {\n    // Mild variant of Bresenham's algorithm;\n    // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx >> 1;\n    var ystep = fromY < toY ? 1 : -1;\n    var xstep = fromX < toX ? 1 : -1;\n    var state = 0; // In black pixels, looking for white, first or second time\n    for (var x = fromX, y = fromY; x != toX; x += xstep) {\n      var realX = steep ? y : x;\n      var realY = steep ? x : y;\n      if (state == 1) {\n        // In white pixels, looking for black\n        if (this.image[realX + realY * qrcode.width]) {\n          state++;\n        }\n      } else {\n        if (!this.image[realX + realY * qrcode.width]) {\n          state++;\n        }\n      }\n      if (state == 3) {\n        // Found black, white, black, and stumbled back onto white; done\n        var diffX = x - fromX;\n        var diffY = y - fromY;\n        return Math.sqrt(diffX * diffX + diffY * diffY);\n      }\n      error += dy;\n      if (error > 0) {\n        if (y == toY) {\n          break;\n        }\n        y += ystep;\n        error -= dx;\n      }\n    }\n    var diffX2 = toX - fromX;\n    var diffY2 = toY - fromY;\n    return Math.sqrt(diffX2 * diffX2 + diffY2 * diffY2);\n  };\n  this.sizeOfBlackWhiteBlackRunBothWays = function (fromX, fromY, toX, toY) {\n    var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n\n    // Now count other way -- don't run off image though of course\n    var scale = 1.0;\n    var otherToX = fromX - (toX - fromX);\n    if (otherToX < 0) {\n      scale = fromX / (fromX - otherToX);\n      otherToX = 0;\n    } else if (otherToX >= qrcode.width) {\n      scale = (qrcode.width - 1 - fromX) / (otherToX - fromX);\n      otherToX = qrcode.width - 1;\n    }\n    var otherToY = Math.floor(fromY - (toY - fromY) * scale);\n    scale = 1.0;\n    if (otherToY < 0) {\n      scale = fromY / (fromY - otherToY);\n      otherToY = 0;\n    } else if (otherToY >= qrcode.height) {\n      scale = (qrcode.height - 1 - fromY) / (otherToY - fromY);\n      otherToY = qrcode.height - 1;\n    }\n    otherToX = Math.floor(fromX + (otherToX - fromX) * scale);\n    result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n    return result - 1.0; // -1 because we counted the middle pixel twice\n  };\n\n  this.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n    var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.X), Math.floor(pattern.Y), Math.floor(otherPattern.X), Math.floor(otherPattern.Y));\n    var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor(pattern.X), Math.floor(pattern.Y));\n    if (isNaN(moduleSizeEst1)) {\n      return moduleSizeEst2 / 7.0;\n    }\n    if (isNaN(moduleSizeEst2)) {\n      return moduleSizeEst1 / 7.0;\n    }\n    // Average them, and divide by 7 since we've counted the width of 3 black modules,\n    // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n    return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n  };\n  this.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n    // Take the average\n    return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n  };\n  this.distance = function (pattern1, pattern2) {\n    xDiff = pattern1.X - pattern2.X;\n    yDiff = pattern1.Y - pattern2.Y;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n  };\n  this.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize) {\n    var tltrCentersDimension = Math.round(this.distance(topLeft, topRight) / moduleSize);\n    var tlblCentersDimension = Math.round(this.distance(topLeft, bottomLeft) / moduleSize);\n    var dimension = (tltrCentersDimension + tlblCentersDimension >> 1) + 7;\n    switch (dimension & 0x03) {\n      // mod 4\n      case 0:\n        dimension++;\n        break;\n      // 1? do nothing\n\n      case 2:\n        dimension--;\n        break;\n      case 3:\n        throw \"Error\";\n    }\n    return dimension;\n  };\n  this.findAlignmentInRegion = function (overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {\n    // Look for an alignment pattern (3 modules in size) around where it\n    // should be\n    var allowance = Math.floor(allowanceFactor * overallEstModuleSize);\n    var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n    var alignmentAreaRightX = Math.min(qrcode.width - 1, estAlignmentX + allowance);\n    if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n      throw \"Error\";\n    }\n    var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n    var alignmentAreaBottomY = Math.min(qrcode.height - 1, estAlignmentY + allowance);\n    var alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n    return alignmentFinder.find();\n  };\n  this.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension) {\n    var dimMinusThree = dimension - 3.5;\n    var bottomRightX;\n    var bottomRightY;\n    var sourceBottomRightX;\n    var sourceBottomRightY;\n    if (alignmentPattern != null) {\n      bottomRightX = alignmentPattern.X;\n      bottomRightY = alignmentPattern.Y;\n      sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0;\n    } else {\n      // Don't have an alignment pattern, just make up the bottom-right point\n      bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\n      bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;\n      sourceBottomRightX = sourceBottomRightY = dimMinusThree;\n    }\n    var transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X, bottomLeft.Y);\n    return transform;\n  };\n  this.sampleGrid = function (image, transform, dimension) {\n    var sampler = grid;\n    return sampler.sampleGrid3(image, dimension, transform);\n  };\n  this.processFinderPatternInfo = function (info) {\n    var topLeft = info.TopLeft;\n    var topRight = info.TopRight;\n    var bottomLeft = info.BottomLeft;\n    var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n    if (moduleSize < 1.0) {\n      throw \"Error\";\n    }\n    var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n    var provisionalVersion = Version.getProvisionalVersionForDimension(dimension);\n    var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;\n    var alignmentPattern = null;\n    // Anything above version 1 has an alignment pattern\n    if (provisionalVersion.AlignmentPatternCenters.length > 0) {\n      // Guess where a \"bottom right\" finder pattern would have been\n      var bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\n      var bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;\n\n      // Estimate that alignment pattern is closer by 3 modules\n      // from \"bottom right\" to known top left location\n      var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n      var estAlignmentX = Math.floor(topLeft.X + correctionToTopLeft * (bottomRightX - topLeft.X));\n      var estAlignmentY = Math.floor(topLeft.Y + correctionToTopLeft * (bottomRightY - topLeft.Y));\n\n      // Kind of arbitrary -- expand search radius before giving up\n      for (var i = 4; i <= 16; i <<= 1) {\n        //try\n        //{\n        alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n        break;\n        //}\n        //catch (re)\n        //{\n        // try next round\n        //}\n      }\n      // If we didn't find alignment pattern... well try anyway without it\n    }\n\n    var transform = this.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n    var bits = this.sampleGrid(this.image, transform, dimension);\n    var points;\n    if (alignmentPattern == null) {\n      points = new Array(bottomLeft, topLeft, topRight);\n    } else {\n      points = new Array(bottomLeft, topLeft, topRight, alignmentPattern);\n    }\n    return new DetectorResult(bits, points);\n  };\n  this.detect = function () {\n    var info = new FinderPatternFinder().findFinderPattern(this.image);\n    return this.processFinderPatternInfo(info);\n  };\n}\nmodule.exports = Detector;","map":{"version":3,"names":["grid","require","Version","PerspectiveTransform","qrcode","AlignmentPatternFinder","FinderPatternFinder","DetectorResult","bits","points","Detector","image","resultPointCallback","sizeOfBlackWhiteBlackRun","fromX","fromY","toX","toY","steep","Math","abs","temp","dx","dy","error","ystep","xstep","state","x","y","realX","realY","width","diffX","diffY","sqrt","diffX2","diffY2","sizeOfBlackWhiteBlackRunBothWays","result","scale","otherToX","otherToY","floor","height","calculateModuleSizeOneWay","pattern","otherPattern","moduleSizeEst1","X","Y","moduleSizeEst2","isNaN","calculateModuleSize","topLeft","topRight","bottomLeft","distance","pattern1","pattern2","xDiff","yDiff","computeDimension","moduleSize","tltrCentersDimension","round","tlblCentersDimension","dimension","findAlignmentInRegion","overallEstModuleSize","estAlignmentX","estAlignmentY","allowanceFactor","allowance","alignmentAreaLeftX","max","alignmentAreaRightX","min","alignmentAreaTopY","alignmentAreaBottomY","alignmentFinder","find","createTransform","alignmentPattern","dimMinusThree","bottomRightX","bottomRightY","sourceBottomRightX","sourceBottomRightY","transform","quadrilateralToQuadrilateral","sampleGrid","sampler","sampleGrid3","processFinderPatternInfo","info","TopLeft","TopRight","BottomLeft","provisionalVersion","getProvisionalVersionForDimension","modulesBetweenFPCenters","DimensionForVersion","AlignmentPatternCenters","length","correctionToTopLeft","i","Array","detect","findFinderPattern","module","exports"],"sources":["/Users/alizhetpis/Documents/duken/frontend/node_modules/jsqrcode/src/detector.js"],"sourcesContent":["/*\r\n  Ported to JavaScript by Lazar Laszlo 2011 \r\n  \r\n  lazarsoft@gmail.com, www.lazarsoft.info\r\n  \r\n*/\r\n\r\n/*\r\n*\r\n* Copyright 2007 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\nvar grid = require('./grid');\r\nvar Version = require('./version');\r\nvar PerspectiveTransform = require('./perspective-transform');\r\nvar qrcode = require('./qrcode')();\r\nvar AlignmentPatternFinder = require('./alignpat');\r\nvar FinderPatternFinder = require('./findpat');\r\n\r\nfunction DetectorResult(bits,  points)\r\n{\r\n  this.bits = bits;\r\n  this.points = points;\r\n}\r\n\r\n\r\nfunction Detector(image)\r\n{\r\n  this.image=image;\r\n  this.resultPointCallback = null;\r\n  \r\n  this.sizeOfBlackWhiteBlackRun=function( fromX,  fromY,  toX,  toY)\r\n    {\r\n      // Mild variant of Bresenham's algorithm;\r\n      // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\r\n      var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\r\n      if (steep)\r\n      {\r\n        var temp = fromX;\r\n        fromX = fromY;\r\n        fromY = temp;\r\n        temp = toX;\r\n        toX = toY;\r\n        toY = temp;\r\n      }\r\n      \r\n      var dx = Math.abs(toX - fromX);\r\n      var dy = Math.abs(toY - fromY);\r\n      var error = - dx >> 1;\r\n      var ystep = fromY < toY?1:- 1;\r\n      var xstep = fromX < toX?1:- 1;\r\n      var state = 0; // In black pixels, looking for white, first or second time\r\n      for (var x = fromX, y = fromY; x != toX; x += xstep)\r\n      {\r\n        \r\n        var realX = steep?y:x;\r\n        var realY = steep?x:y;\r\n        if (state == 1)\r\n        {\r\n          // In white pixels, looking for black\r\n          if (this.image[realX + realY*qrcode.width])\r\n          {\r\n            state++;\r\n          }\r\n        }\r\n        else\r\n        {\r\n          if (!this.image[realX + realY*qrcode.width])\r\n          {\r\n            state++;\r\n          }\r\n        }\r\n        \r\n        if (state == 3)\r\n        {\r\n          // Found black, white, black, and stumbled back onto white; done\r\n          var diffX = x - fromX;\r\n          var diffY = y - fromY;\r\n          return  Math.sqrt( (diffX * diffX + diffY * diffY));\r\n        }\r\n        error += dy;\r\n        if (error > 0)\r\n        {\r\n          if (y == toY)\r\n          {\r\n            break;\r\n          }\r\n          y += ystep;\r\n          error -= dx;\r\n        }\r\n      }\r\n      var diffX2 = toX - fromX;\r\n      var diffY2 = toY - fromY;\r\n      return  Math.sqrt( (diffX2 * diffX2 + diffY2 * diffY2));\r\n    }\r\n\r\n  \r\n  this.sizeOfBlackWhiteBlackRunBothWays=function( fromX,  fromY,  toX,  toY)\r\n    {\r\n      \r\n      var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\r\n      \r\n      // Now count other way -- don't run off image though of course\r\n      var scale = 1.0;\r\n      var otherToX = fromX - (toX - fromX);\r\n      if (otherToX < 0)\r\n      {\r\n        scale =  fromX /  (fromX - otherToX);\r\n        otherToX = 0;\r\n      }\r\n      else if (otherToX >= qrcode.width)\r\n      {\r\n        scale =  (qrcode.width - 1 - fromX) /  (otherToX - fromX);\r\n        otherToX = qrcode.width - 1;\r\n      }\r\n      var otherToY = Math.floor (fromY - (toY - fromY) * scale);\r\n      \r\n      scale = 1.0;\r\n      if (otherToY < 0)\r\n      {\r\n        scale =  fromY /  (fromY - otherToY);\r\n        otherToY = 0;\r\n      }\r\n      else if (otherToY >= qrcode.height)\r\n      {\r\n        scale =  (qrcode.height - 1 - fromY) /  (otherToY - fromY);\r\n        otherToY = qrcode.height - 1;\r\n      }\r\n      otherToX = Math.floor (fromX + (otherToX - fromX) * scale);\r\n      \r\n      result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\r\n      return result - 1.0; // -1 because we counted the middle pixel twice\r\n    }\r\n    \r\n\r\n  \r\n  this.calculateModuleSizeOneWay=function( pattern,  otherPattern)\r\n    {\r\n      var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor( pattern.X), Math.floor( pattern.Y), Math.floor( otherPattern.X), Math.floor(otherPattern.Y));\r\n      var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor( pattern.X), Math.floor(pattern.Y));\r\n      if (isNaN(moduleSizeEst1))\r\n      {\r\n        return moduleSizeEst2 / 7.0;\r\n      }\r\n      if (isNaN(moduleSizeEst2))\r\n      {\r\n        return moduleSizeEst1 / 7.0;\r\n      }\r\n      // Average them, and divide by 7 since we've counted the width of 3 black modules,\r\n      // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\r\n      return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\r\n    }\r\n\r\n  \r\n  this.calculateModuleSize=function( topLeft,  topRight,  bottomLeft)\r\n    {\r\n      // Take the average\r\n      return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\r\n    }\r\n\r\n  this.distance=function( pattern1,  pattern2)\r\n  {\r\n    xDiff = pattern1.X - pattern2.X;\r\n    yDiff = pattern1.Y - pattern2.Y;\r\n    return  Math.sqrt( (xDiff * xDiff + yDiff * yDiff));\r\n  }\r\n  this.computeDimension=function( topLeft,  topRight,  bottomLeft,  moduleSize)\r\n    {\r\n      \r\n      var tltrCentersDimension = Math.round(this.distance(topLeft, topRight) / moduleSize);\r\n      var tlblCentersDimension = Math.round(this.distance(topLeft, bottomLeft) / moduleSize);\r\n      var dimension = ((tltrCentersDimension + tlblCentersDimension) >> 1) + 7;\r\n      switch (dimension & 0x03)\r\n      {\r\n        \r\n        // mod 4\r\n        case 0: \r\n          dimension++;\r\n          break;\r\n          // 1? do nothing\r\n        \r\n        case 2: \r\n          dimension--;\r\n          break;\r\n        \r\n        case 3: \r\n          throw \"Error\";\r\n        }\r\n      return dimension;\r\n    }\r\n\r\n  this.findAlignmentInRegion=function( overallEstModuleSize,  estAlignmentX,  estAlignmentY,  allowanceFactor)\r\n    {\r\n      // Look for an alignment pattern (3 modules in size) around where it\r\n      // should be\r\n      var allowance = Math.floor (allowanceFactor * overallEstModuleSize);\r\n      var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\r\n      var alignmentAreaRightX = Math.min(qrcode.width - 1, estAlignmentX + allowance);\r\n      if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3)\r\n      {\r\n        throw \"Error\";\r\n      }\r\n      \r\n      var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\r\n      var alignmentAreaBottomY = Math.min(qrcode.height - 1, estAlignmentY + allowance);\r\n      \r\n      var alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\r\n      return alignmentFinder.find();\r\n    }\r\n    \r\n  this.createTransform=function( topLeft,  topRight,  bottomLeft, alignmentPattern, dimension)\r\n    {\r\n      var dimMinusThree =  dimension - 3.5;\r\n      var bottomRightX;\r\n      var bottomRightY;\r\n      var sourceBottomRightX;\r\n      var sourceBottomRightY;\r\n      if (alignmentPattern != null)\r\n      {\r\n        bottomRightX = alignmentPattern.X;\r\n        bottomRightY = alignmentPattern.Y;\r\n        sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0;\r\n      }\r\n      else\r\n      {\r\n        // Don't have an alignment pattern, just make up the bottom-right point\r\n        bottomRightX = (topRight.X - topLeft.X) + bottomLeft.X;\r\n        bottomRightY = (topRight.Y - topLeft.Y) + bottomLeft.Y;\r\n        sourceBottomRightX = sourceBottomRightY = dimMinusThree;\r\n      }\r\n      \r\n      var transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X, bottomLeft.Y);\r\n      \r\n      return transform;\r\n    }    \r\n  \r\n  this.sampleGrid = function( image,  transform,  dimension)\r\n    {\r\n      \r\n      var sampler = grid;\r\n      return sampler.sampleGrid3(image, dimension, transform);\r\n    }\r\n  \r\n  this.processFinderPatternInfo = function( info)\r\n    {\r\n      \r\n      var topLeft = info.TopLeft;\r\n      var topRight = info.TopRight;\r\n      var bottomLeft = info.BottomLeft;\r\n      \r\n      var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\r\n      if (moduleSize < 1.0)\r\n      {\r\n        throw \"Error\";\r\n      }\r\n      var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\r\n      var provisionalVersion = Version.getProvisionalVersionForDimension(dimension);\r\n      var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;\r\n      \r\n      var alignmentPattern = null;\r\n      // Anything above version 1 has an alignment pattern\r\n      if (provisionalVersion.AlignmentPatternCenters.length > 0)\r\n      {\r\n        \r\n        // Guess where a \"bottom right\" finder pattern would have been\r\n        var bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\r\n        var bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;\r\n        \r\n        // Estimate that alignment pattern is closer by 3 modules\r\n        // from \"bottom right\" to known top left location\r\n        var correctionToTopLeft = 1.0 - 3.0 /  modulesBetweenFPCenters;\r\n        var estAlignmentX = Math.floor (topLeft.X + correctionToTopLeft * (bottomRightX - topLeft.X));\r\n        var estAlignmentY = Math.floor (topLeft.Y + correctionToTopLeft * (bottomRightY - topLeft.Y));\r\n        \r\n        // Kind of arbitrary -- expand search radius before giving up\r\n        for (var i = 4; i <= 16; i <<= 1)\r\n        {\r\n          //try\r\n          //{\r\n            alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY,  i);\r\n            break;\r\n          //}\r\n          //catch (re)\r\n          //{\r\n            // try next round\r\n          //}\r\n        }\r\n        // If we didn't find alignment pattern... well try anyway without it\r\n      }\r\n      \r\n      var transform = this.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\r\n      \r\n      var bits = this.sampleGrid(this.image, transform, dimension);\r\n      \r\n      var points;\r\n      if (alignmentPattern == null)\r\n      {\r\n        points = new Array(bottomLeft, topLeft, topRight);\r\n      }\r\n      else\r\n      {\r\n        points = new Array(bottomLeft, topLeft, topRight, alignmentPattern);\r\n      }\r\n      return new DetectorResult(bits, points);\r\n    }\r\n  \r\n  this.detect = function() {\r\n    var info =  new FinderPatternFinder().findFinderPattern(this.image);\r\n    return this.processFinderPatternInfo(info);\r\n  }\r\n}\r\n\r\nmodule.exports = Detector;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}